; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\stm32f4xx_gpio.crf drivers\stm32f4xx_gpio.c]
                          THUMB

                          AREA ||i.GPIO_DeInit||, CODE, READONLY, ALIGN=2

                  GPIO_DeInit PROC
;;;119      */
;;;120    void GPIO_DeInit(GPIO_TypeDef* GPIOx)
000000  4920              LDR      r1,|L1.132|
;;;121    {
000002  b510              PUSH     {r4,lr}
;;;122      /* Check the parameters */
;;;123      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;124    
;;;125      if (GPIOx == GPIOA)
000004  4288              CMP      r0,r1
000006  d106              BNE      |L1.22|
;;;126      {
;;;127        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;128        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  e030              B        |L1.120|
                  |L1.22|
;;;129      }
;;;130      else if (GPIOx == GPIOB)
000016  491c              LDR      r1,|L1.136|
000018  4288              CMP      r0,r1
00001a  d106              BNE      |L1.42|
;;;131      {
;;;132        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  2002              MOVS     r0,#2
000020  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;133        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
000024  2100              MOVS     r1,#0
000026  2002              MOVS     r0,#2
000028  e026              B        |L1.120|
                  |L1.42|
;;;134      }
;;;135      else if (GPIOx == GPIOC)
00002a  4918              LDR      r1,|L1.140|
00002c  4288              CMP      r0,r1
00002e  d106              BNE      |L1.62|
;;;136      {
;;;137        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
000030  2101              MOVS     r1,#1
000032  2004              MOVS     r0,#4
000034  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;138        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
000038  2100              MOVS     r1,#0
00003a  2004              MOVS     r0,#4
00003c  e01c              B        |L1.120|
                  |L1.62|
;;;139      }
;;;140      else if (GPIOx == GPIOD)
00003e  4914              LDR      r1,|L1.144|
000040  4288              CMP      r0,r1
000042  d106              BNE      |L1.82|
;;;141      {
;;;142        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
000044  2101              MOVS     r1,#1
000046  2008              MOVS     r0,#8
000048  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;143        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  2008              MOVS     r0,#8
000050  e012              B        |L1.120|
                  |L1.82|
;;;144      }
;;;145      else if (GPIOx == GPIOE)
000052  4910              LDR      r1,|L1.148|
000054  4288              CMP      r0,r1
000056  d106              BNE      |L1.102|
;;;146      {
;;;147        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2010              MOVS     r0,#0x10
00005c  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;148        RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
000060  2100              MOVS     r1,#0
000062  2010              MOVS     r0,#0x10
000064  e008              B        |L1.120|
                  |L1.102|
;;;149      }
;;;150      else 
;;;151    	{
;;;152    		if (GPIOx == GPIOH)
000066  490c              LDR      r1,|L1.152|
000068  4288              CMP      r0,r1
00006a  d109              BNE      |L1.128|
;;;153    		{
;;;154    			RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2080              MOVS     r0,#0x80
000070  f7fffffe          BL       RCC_AHB1PeriphResetCmd
;;;155    			RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
000074  2100              MOVS     r1,#0
000076  2080              MOVS     r0,#0x80
                  |L1.120|
000078  e8bd4010          POP      {r4,lr}
00007c  f7ffbffe          B.W      RCC_AHB1PeriphResetCmd
                  |L1.128|
;;;156    		}
;;;157    	}
;;;158    }
000080  bd10              POP      {r4,pc}
;;;159    
                          ENDP

000082  0000              DCW      0x0000
                  |L1.132|
                          DCD      0x40020000
                  |L1.136|
                          DCD      0x40020400
                  |L1.140|
                          DCD      0x40020800
                  |L1.144|
                          DCD      0x40020c00
                  |L1.148|
                          DCD      0x40021000
                  |L1.152|
                          DCD      0x40021c00

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=1

                  GPIO_Init PROC
;;;166      */
;;;167    void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;168    {
;;;169      uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
000002  2300              MOVS     r3,#0
;;;170    
;;;171      /* Check the parameters */
;;;172      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;173      //assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;174      //assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;175      //assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
;;;176    
;;;177      /* -------------------------Configure the port pins---------------- */
;;;178      /*-- GPIO Mode Configuration --*/
;;;179      for (pinpos = 0x00; pinpos < 0x10; pinpos++)
;;;180      {
;;;181        pos = ((uint32_t)0x01) << pinpos;
000004  2401              MOVS     r4,#1
;;;182        /* Get the port pins position */
;;;183        currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
;;;184    
;;;185        if (currentpin == pos)
;;;186        {
;;;187          GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
000006  2703              MOVS     r7,#3
                  |L2.8|
000008  680d              LDR      r5,[r1,#0]            ;183
00000a  fa04f203          LSL      r2,r4,r3              ;181
00000e  4015              ANDS     r5,r5,r2              ;183
000010  4295              CMP      r5,r2                 ;185
000012  d142              BNE      |L2.154|
000014  f8d0c000          LDR      r12,[r0,#0]
000018  005e              LSLS     r6,r3,#1
00001a  fa07f506          LSL      r5,r7,r6
00001e  ea2c0c05          BIC      r12,r12,r5
000022  f8c0c000          STR      r12,[r0,#0]
;;;188          GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
000026  f891c004          LDRB     r12,[r1,#4]
00002a  f8d0e000          LDR      lr,[r0,#0]
00002e  fa0cfc06          LSL      r12,r12,r6
000032  ea4c0c0e          ORR      r12,r12,lr
000036  f8c0c000          STR      r12,[r0,#0]
;;;189    
;;;190          if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
00003a  f891c004          LDRB     r12,[r1,#4]
00003e  f1bc0f01          CMP      r12,#1
000042  d002              BEQ      |L2.74|
000044  f1bc0f02          CMP      r12,#2
000048  d11f              BNE      |L2.138|
                  |L2.74|
;;;191          {
;;;192            /* Check Speed mode parameters */
;;;193            //assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
;;;194    
;;;195            /* Speed mode configuration */
;;;196            GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
00004a  f8d0c008          LDR      r12,[r0,#8]
00004e  ea2c0c05          BIC      r12,r12,r5
000052  f8c0c008          STR      r12,[r0,#8]
;;;197            GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
000056  f891c005          LDRB     r12,[r1,#5]
00005a  f8d0e008          LDR      lr,[r0,#8]
00005e  fa0cfc06          LSL      r12,r12,r6
000062  ea4c0c0e          ORR      r12,r12,lr
000066  f8c0c008          STR      r12,[r0,#8]
;;;198    
;;;199            /* Check Output mode parameters */
;;;200            //assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
;;;201    
;;;202            /* Output mode configuration*/
;;;203            GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
00006a  f8d0c004          LDR      r12,[r0,#4]
00006e  ea2c0c02          BIC      r12,r12,r2
000072  f8c0c004          STR      r12,[r0,#4]
;;;204            GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
000076  6842              LDR      r2,[r0,#4]
000078  f891c006          LDRB     r12,[r1,#6]
00007c  fa0cfc03          LSL      r12,r12,r3
000080  fa1ffc8c          UXTH     r12,r12
000084  ea42020c          ORR      r2,r2,r12
000088  6042              STR      r2,[r0,#4]
                  |L2.138|
;;;205          }
;;;206    
;;;207          /* Pull-up Pull down resistor configuration*/
;;;208          GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
00008a  68c2              LDR      r2,[r0,#0xc]
00008c  43aa              BICS     r2,r2,r5
00008e  60c2              STR      r2,[r0,#0xc]
;;;209          GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
000090  79ca              LDRB     r2,[r1,#7]
000092  68c5              LDR      r5,[r0,#0xc]
000094  40b2              LSLS     r2,r2,r6
000096  432a              ORRS     r2,r2,r5
000098  60c2              STR      r2,[r0,#0xc]
                  |L2.154|
00009a  1c5b              ADDS     r3,r3,#1
00009c  2b10              CMP      r3,#0x10              ;179
00009e  d3b3              BCC      |L2.8|
;;;210        }
;;;211      }
;;;212    }
0000a0  bdf0              POP      {r4-r7,pc}
;;;213    
                          ENDP


                          AREA ||i.GPIO_PinAFConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinAFConfig PROC
;;;513      */
;;;514    void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
000000  074b              LSLS     r3,r1,#29
;;;515    {
;;;516      uint32_t temp = 0x00;
;;;517      uint32_t temp_2 = 0x00;
;;;518      
;;;519      /* Check the parameters */
;;;520      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;521      //assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
;;;522      //assert_param(IS_GPIO_AF(GPIO_AF));
;;;523      
;;;524      temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
000002  0edb              LSRS     r3,r3,#27
000004  409a              LSLS     r2,r2,r3
;;;525      GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
000006  08c9              LSRS     r1,r1,#3
000008  b510              PUSH     {r4,lr}               ;515
00000a  eb000081          ADD      r0,r0,r1,LSL #2
00000e  6a01              LDR      r1,[r0,#0x20]
000010  240f              MOVS     r4,#0xf
000012  409c              LSLS     r4,r4,r3
000014  43a1              BICS     r1,r1,r4
000016  6201              STR      r1,[r0,#0x20]
;;;526      temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
000018  6a01              LDR      r1,[r0,#0x20]
00001a  4311              ORRS     r1,r1,r2
;;;527      GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
00001c  6201              STR      r1,[r0,#0x20]
;;;528    }
00001e  bd10              POP      {r4,pc}
;;;529    
                          ENDP


                          AREA ||i.GPIO_PinLockConfig||, CODE, READONLY, ALIGN=1

                  GPIO_PinLockConfig PROC
;;;239      */
;;;240    void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  b508              PUSH     {r3,lr}
;;;241    {
;;;242      __IO uint32_t tmp = 0x00010000;
;;;243    
;;;244      /* Check the parameters */
;;;245      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;246      //assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;247    
;;;248      tmp |= GPIO_Pin;
000002  f4413280          ORR      r2,r1,#0x10000
;;;249      /* Set LCKK bit */
;;;250      GPIOx->LCKR = tmp;
000006  9200              STR      r2,[sp,#0]
000008  61c2              STR      r2,[r0,#0x1c]
;;;251      /* Reset LCKK bit */
;;;252      GPIOx->LCKR =  GPIO_Pin;
00000a  61c1              STR      r1,[r0,#0x1c]
;;;253      /* Set LCKK bit */
;;;254      GPIOx->LCKR = tmp;
00000c  9900              LDR      r1,[sp,#0]
00000e  61c1              STR      r1,[r0,#0x1c]
;;;255      /* Read LCKK bit*/
;;;256      tmp = GPIOx->LCKR;
000010  69c1              LDR      r1,[r0,#0x1c]
;;;257      /* Read LCKK bit*/
;;;258      tmp = GPIOx->LCKR;
000012  69c0              LDR      r0,[r0,#0x1c]
000014  9000              STR      r0,[sp,#0]
;;;259    }
000016  bd08              POP      {r3,pc}
;;;260    
                          ENDP


                          AREA ||i.GPIO_ReadInputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputData PROC
;;;307      */
;;;308    uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
000000  6900              LDR      r0,[r0,#0x10]
;;;309    {
;;;310      /* Check the parameters */
;;;311      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;312    
;;;313      return ((uint16_t)GPIOx->IDR);
000002  b280              UXTH     r0,r0
;;;314    }
000004  4770              BX       lr
;;;315    
                          ENDP


                          AREA ||i.GPIO_ReadInputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadInputDataBit PROC
;;;283      */
;;;284    uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;285    {
;;;286      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;287    
;;;288      /* Check the parameters */
;;;289      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;290      //assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;291    
;;;292      if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  6912              LDR      r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L6.12|
;;;293      {
;;;294        bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
                  |L6.12|
;;;295      }
;;;296      else
;;;297      {
;;;298        bitstatus = (uint8_t)Bit_RESET;
;;;299      }
;;;300      return bitstatus;
;;;301    }
00000c  4770              BX       lr
;;;302    
                          ENDP


                          AREA ||i.GPIO_ReadOutputData||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputData PROC
;;;346      */
;;;347    uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
000000  6940              LDR      r0,[r0,#0x14]
;;;348    {
;;;349      /* Check the parameters */
;;;350      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;351    
;;;352      return ((uint16_t)GPIOx->ODR);
000002  b280              UXTH     r0,r0
;;;353    }
000004  4770              BX       lr
;;;354    
                          ENDP


                          AREA ||i.GPIO_ReadOutputDataBit||, CODE, READONLY, ALIGN=1

                  GPIO_ReadOutputDataBit PROC
;;;322      */
;;;323    uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  4602              MOV      r2,r0
;;;324    {
;;;325      uint8_t bitstatus = 0x00;
000002  2000              MOVS     r0,#0
;;;326    
;;;327      /* Check the parameters */
;;;328      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;329      //assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;330    
;;;331      if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
000004  6952              LDR      r2,[r2,#0x14]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;332      {
;;;333        bitstatus = (uint8_t)Bit_SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;334      }
;;;335      else
;;;336      {
;;;337        bitstatus = (uint8_t)Bit_RESET;
;;;338      }
;;;339      return bitstatus;
;;;340    }
00000c  4770              BX       lr
;;;341    
                          ENDP


                          AREA ||i.GPIO_ResetBits||, CODE, READONLY, ALIGN=1

                  GPIO_ResetBits PROC
;;;383      */
;;;384    void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6181              STR      r1,[r0,#0x18]
;;;385    {
;;;386      /* Check the parameters */
;;;387      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;388      //assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;389    
;;;390      GPIOx->BSRR = GPIO_Pin;
;;;391    }
000002  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.GPIO_SetBits||, CODE, READONLY, ALIGN=1

                  GPIO_SetBits PROC
;;;364      */
;;;365    void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6181              STR      r1,[r0,#0x18]
;;;366    {
;;;367      /* Check the parameters */
;;;368      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;369      //assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;370    
;;;371      GPIOx->BSRR = GPIO_Pin;
;;;372    }
000002  4770              BX       lr
;;;373    
                          ENDP


                          AREA ||i.GPIO_StructInit||, CODE, READONLY, ALIGN=1

                  GPIO_StructInit PROC
;;;218      */
;;;219    void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;220    {
;;;221      /* Reset GPIO init structure parameters values */
;;;222      GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
;;;223      GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  7101              STRB     r1,[r0,#4]
;;;224      GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
00000a  7141              STRB     r1,[r0,#5]
;;;225      GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
00000c  7181              STRB     r1,[r0,#6]
;;;226      GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
00000e  71c1              STRB     r1,[r0,#7]
;;;227    }
000010  4770              BX       lr
;;;228    
                          ENDP


                          AREA ||i.GPIO_ToggleBits||, CODE, READONLY, ALIGN=1

                  GPIO_ToggleBits PROC
;;;440      */
;;;441    void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
000000  6942              LDR      r2,[r0,#0x14]
;;;442    {
;;;443      /* Check the parameters */
;;;444      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;445    
;;;446      GPIOx->ODR ^= GPIO_Pin;
000002  404a              EORS     r2,r2,r1
000004  6142              STR      r2,[r0,#0x14]
;;;447    }
000006  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.GPIO_Write||, CODE, READONLY, ALIGN=1

                  GPIO_Write PROC
;;;426      */
;;;427    void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
000000  6141              STR      r1,[r0,#0x14]
;;;428    {
;;;429      /* Check the parameters */
;;;430      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;431    
;;;432      GPIOx->ODR = PortVal;
;;;433    }
000002  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.GPIO_WriteBit||, CODE, READONLY, ALIGN=1

                  GPIO_WriteBit PROC
;;;403      */
;;;404    void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
000000  6181              STR      r1,[r0,#0x18]
;;;405    {
;;;406      /* Check the parameters */
;;;407      //assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
;;;408      //assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;409      //assert_param(IS_GPIO_BIT_ACTION(BitVal));
;;;410    
;;;411      if (BitVal != Bit_RESET)
;;;412      {
;;;413        GPIOx->BSRR = GPIO_Pin;
;;;414      }
;;;415      else
;;;416      {
;;;417        GPIOx->BSRR = GPIO_Pin ;
;;;418      }
;;;419    }
000002  4770              BX       lr
;;;420    
                          ENDP


;*** Start embedded assembler ***

#line 1 "drivers\\stm32f4xx_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_gpio_c_f8e8e39a____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___16_stm32f4xx_gpio_c_f8e8e39a____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_gpio_c_f8e8e39a____REVSH|
#line 223
|__asm___16_stm32f4xx_gpio_c_f8e8e39a____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_stm32f4xx_gpio_c_f8e8e39a____RRX|
#line 410
|__asm___16_stm32f4xx_gpio_c_f8e8e39a____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
