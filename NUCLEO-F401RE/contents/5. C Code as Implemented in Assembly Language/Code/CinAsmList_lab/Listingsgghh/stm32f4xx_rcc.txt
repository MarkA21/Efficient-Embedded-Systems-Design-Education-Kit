; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_rcc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_rcc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\stm32f4xx_rcc.crf drivers\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1100     */
;;;1101   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L1.20|
;;;1102   {
;;;1103     /* Check the parameters */
;;;1104     //assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1105   
;;;1106     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1107     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1108     {
;;;1109       RCC->AHB1ENR |= RCC_AHB1Periph;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       RCC->AHB1ENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;1109
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;1109
;;;1114     }
;;;1115   }
000010  4770              BX       lr
;;;1116   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1470     */
;;;1471   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1472   {
;;;1473     /* Check the parameters */
;;;1474     //assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1475     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1476     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1477     {
;;;1478       RCC->AHB1LPENR |= RCC_AHB1Periph;
;;;1479     }
;;;1480     else
;;;1481     {
;;;1482       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1478
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6011              STR      r1,[r2,#0]            ;1478
;;;1483     }
;;;1484   }
000010  4770              BX       lr
;;;1485   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1288     */
;;;1289   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1290   {
;;;1291     /* Check the parameters */
;;;1292     //assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1293     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1294   
;;;1295     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1296     {
;;;1297       RCC->AHB1RSTR |= RCC_AHB1Periph;
;;;1298     }
;;;1299     else
;;;1300     {
;;;1301       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1297
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6011              STR      r1,[r2,#0]            ;1297
;;;1302     }
;;;1303   }
000010  4770              BX       lr
;;;1304   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1132     */
;;;1133   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1134   {
;;;1135     /* Check the parameters */
;;;1136     //assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1137     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1138   
;;;1139     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1140     {
;;;1141       RCC->AHB2ENR |= RCC_AHB2Periph;
;;;1142     }
;;;1143     else
;;;1144     {
;;;1145       RCC->AHB2ENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1141
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6011              STR      r1,[r2,#0]            ;1141
;;;1146     }
;;;1147   }
000010  4770              BX       lr
;;;1148   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1502     */
;;;1503   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1504   {
;;;1505     /* Check the parameters */
;;;1506     //assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1507     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1508     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1509     {
;;;1510       RCC->AHB2LPENR |= RCC_AHB2Periph;
;;;1511     }
;;;1512     else
;;;1513     {
;;;1514       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1510
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;1510
;;;1515     }
;;;1516   }
000010  4770              BX       lr
;;;1517   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1317     */
;;;1318   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1319   {
;;;1320     /* Check the parameters */
;;;1321     //assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1322     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1323   
;;;1324     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1325     {
;;;1326       RCC->AHB2RSTR |= RCC_AHB2Periph;
;;;1327     }
;;;1328     else
;;;1329     {
;;;1330       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1326
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6011              STR      r1,[r2,#0]            ;1326
;;;1331     }
;;;1332   }
000010  4770              BX       lr
;;;1333   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1159     */
;;;1160   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1161   {
;;;1162     /* Check the parameters */
;;;1163     //assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1164     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1165   
;;;1166     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1167     {
;;;1168       RCC->AHB3ENR |= RCC_AHB3Periph;
;;;1169     }
;;;1170     else
;;;1171     {
;;;1172       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;1168
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  6011              STR      r1,[r2,#0]            ;1168
;;;1173     }
;;;1174   }
000010  4770              BX       lr
;;;1175   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1529     */
;;;1530   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;1531   {
;;;1532     /* Check the parameters */
;;;1533     //assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1534     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1535     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1536     {
;;;1537       RCC->AHB3LPENR |= RCC_AHB3Periph;
;;;1538     }
;;;1539     else
;;;1540     {
;;;1541       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;1537
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6011              STR      r1,[r2,#0]            ;1537
;;;1542     }
;;;1543   }
000010  4770              BX       lr
;;;1544   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1341     */
;;;1342   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;1343   {
;;;1344     /* Check the parameters */
;;;1345     //assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1346     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1347   
;;;1348     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1349     {
;;;1350       RCC->AHB3RSTR |= RCC_AHB3Periph;
;;;1351     }
;;;1352     else
;;;1353     {
;;;1354       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;1350
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;1350
;;;1355     }
;;;1356   }
000010  4770              BX       lr
;;;1357   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1209     */
;;;1210   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;1211   {
;;;1212     /* Check the parameters */
;;;1213     //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1214     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1215   
;;;1216     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1217     {
;;;1218       RCC->APB1ENR |= RCC_APB1Periph;
;;;1219     }
;;;1220     else
;;;1221     {
;;;1222       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;1218
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6011              STR      r1,[r2,#0]            ;1218
;;;1223     }
;;;1224   }
000010  4770              BX       lr
;;;1225   
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1579     */
;;;1580   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;1581   {
;;;1582     /* Check the parameters */
;;;1583     //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1584     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1585     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1586     {
;;;1587       RCC->APB1LPENR |= RCC_APB1Periph;
;;;1588     }
;;;1589     else
;;;1590     {
;;;1591       RCC->APB1LPENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L11.12|
000008  4301              ORRS     r1,r1,r0              ;1587
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  4381              BICS     r1,r1,r0
                  |L11.14|
00000e  6011              STR      r1,[r2,#0]            ;1587
;;;1592     }
;;;1593   }
000010  4770              BX       lr
;;;1594   
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1388     */
;;;1389   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L12.20|
;;;1390   {
;;;1391     /* Check the parameters */
;;;1392     //assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1393     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1394     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1395     {
;;;1396       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1397     }
;;;1398     else
;;;1399     {
;;;1400       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L12.12|
000008  4301              ORRS     r1,r1,r0              ;1396
00000a  e000              B        |L12.14|
                  |L12.12|
00000c  4381              BICS     r1,r1,r0
                  |L12.14|
00000e  6011              STR      r1,[r2,#0]            ;1396
;;;1401     }
;;;1402   }
000010  4770              BX       lr
;;;1403   
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1249     */
;;;1250   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L13.20|
;;;1251   {
;;;1252     /* Check the parameters */
;;;1253     //assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1254     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1255   
;;;1256     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1257     {
;;;1258       RCC->APB2ENR |= RCC_APB2Periph;
;;;1259     }
;;;1260     else
;;;1261     {
;;;1262       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;1258
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6011              STR      r1,[r2,#0]            ;1258
;;;1263     }
;;;1264   }
000010  4770              BX       lr
;;;1265   
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1619     */
;;;1620   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L14.20|
;;;1621   {
;;;1622     /* Check the parameters */
;;;1623     //assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1624     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1625     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1626     {
;;;1627       RCC->APB2LPENR |= RCC_APB2Periph;
;;;1628     }
;;;1629     else
;;;1630     {
;;;1631       RCC->APB2LPENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L14.12|
000008  4301              ORRS     r1,r1,r0              ;1627
00000a  e000              B        |L14.14|
                  |L14.12|
00000c  4381              BICS     r1,r1,r0
                  |L14.14|
00000e  6011              STR      r1,[r2,#0]            ;1627
;;;1632     }
;;;1633   }
000010  4770              BX       lr
;;;1634   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1424     */
;;;1425   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L15.20|
;;;1426   {
;;;1427     /* Check the parameters */
;;;1428     //assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1429     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1430     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1431     {
;;;1432       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1433     }
;;;1434     else
;;;1435     {
;;;1436       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L15.12|
000008  4301              ORRS     r1,r1,r0              ;1432
00000a  e000              B        |L15.14|
                  |L15.12|
00000c  4381              BICS     r1,r1,r0
                  |L15.14|
00000e  6011              STR      r1,[r2,#0]            ;1432
;;;1437     }
;;;1438   }
000010  4770              BX       lr
;;;1439   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;307      */
;;;308    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4903              LDR      r1,|L16.16|
;;;309    {
;;;310      uint32_t tmpreg = 0;
;;;311      /* Check the parameters */
;;;312      //assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;313    
;;;314      tmpreg = RCC->CR;
000002  680a              LDR      r2,[r1,#0]
;;;315    
;;;316      /* Clear HSITRIM[4:0] bits */
;;;317      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02202f8          BIC      r2,r2,#0xf8
;;;318    
;;;319      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;320      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;321    
;;;322      /* Store the new value */
;;;323      RCC->CR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;324    }
00000e  4770              BX       lr
;;;325    
                          ENDP

                  |L16.16|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1044     */
;;;1045   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1046   {
;;;1047     /* Check the parameters */
;;;1048     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1049     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1050   }
000004  4770              BX       lr
;;;1051   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1745     */
;;;1746   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L18.12|
;;;1747   {
;;;1748     /* Set RMVF bit to clear the reset flags */
;;;1749     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;1750   }
00000a  4770              BX       lr
;;;1751   
                          ENDP

                  |L18.12|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1797     */
;;;1798   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;1799   {
;;;1800     /* Check the parameters */
;;;1801     //assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1802   
;;;1803     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1804        pending bits */
;;;1805     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;1806   }
000004  4770              BX       lr
;;;1807   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;533      */
;;;534    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;535    {
;;;536      /* Check the parameters */
;;;537      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;538      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;539    }
000004  4770              BX       lr
;;;540    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;211      */
;;;212    void RCC_DeInit(void)
000000  480b              LDR      r0,|L21.48|
;;;213    {
;;;214      /* Set HSION bit */
;;;215      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;216    
;;;217      /* Reset CFGR register */
;;;218      RCC->CFGR = 0x00000000;
00000a  4a09              LDR      r2,|L21.48|
00000c  2100              MOVS     r1,#0
00000e  3208              ADDS     r2,r2,#8
000010  6011              STR      r1,[r2,#0]
;;;219    
;;;220      /* Reset HSEON, CSSON and PLLON bits */
;;;221      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6802              LDR      r2,[r0,#0]
000014  4b07              LDR      r3,|L21.52|
000016  401a              ANDS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;222    
;;;223      /* Reset PLLCFGR register */
;;;224      RCC->PLLCFGR = 0x24003010;
00001a  1d03              ADDS     r3,r0,#4
00001c  4a06              LDR      r2,|L21.56|
00001e  601a              STR      r2,[r3,#0]
;;;225    
;;;226      /* Reset HSEBYP bit */
;;;227      RCC->CR &= (uint32_t)0xFFFBFFFF;
000020  6802              LDR      r2,[r0,#0]
000022  f4222280          BIC      r2,r2,#0x40000
000026  6002              STR      r2,[r0,#0]
;;;228    
;;;229      /* Disable all interrupts */
;;;230      RCC->CIR = 0x00000000;
000028  4801              LDR      r0,|L21.48|
00002a  300c              ADDS     r0,r0,#0xc
00002c  6001              STR      r1,[r0,#0]
;;;231    }
00002e  4770              BX       lr
;;;232    
                          ENDP

                  |L21.48|
                          DCD      0x40023800
                  |L21.52|
                          DCD      0xfef6ffff
                  |L21.56|
                          DCD      0x24003010

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;870      */
;;;871    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b570              PUSH     {r4-r6,lr}
;;;872    {
;;;873      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;874    
;;;875      /* Get SYSCLK source -------------------------------------------------------*/
;;;876      tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4a20              LDR      r2,|L22.132|
000004  6811              LDR      r1,[r2,#0]
;;;877    
;;;878      switch (tmp)
;;;879      {
;;;880        case 0x00:  /* HSI used as system clock source */
;;;881          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4c20              LDR      r4,|L22.136|
000008  f011010c          ANDS     r1,r1,#0xc            ;876
00000c  d004              BEQ      |L22.24|
;;;882          break;
;;;883        case 0x04:  /* HSE used as system clock  source */
;;;884          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00000e  4e1f              LDR      r6,|L22.140|
000010  2904              CMP      r1,#4                 ;878
000012  d003              BEQ      |L22.28|
000014  2908              CMP      r1,#8                 ;878
000016  d003              BEQ      |L22.32|
                  |L22.24|
000018  6004              STR      r4,[r0,#0]            ;882
00001a  e01b              B        |L22.84|
                  |L22.28|
;;;885          break;
00001c  6006              STR      r6,[r0,#0]
00001e  e019              B        |L22.84|
                  |L22.32|
;;;886        case 0x08:  /* PLL used as system clock  source */
;;;887    
;;;888          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;889             SYSCLK = PLL_VCO / PLLP
;;;890             */    
;;;891          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
000020  4918              LDR      r1,|L22.132|
000022  1f09              SUBS     r1,r1,#4
000024  680b              LDR      r3,[r1,#0]
000026  f3c35580          UBFX     r5,r3,#22,#1
;;;892          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
00002a  680b              LDR      r3,[r1,#0]
00002c  f003033f          AND      r3,r3,#0x3f
;;;893          
;;;894          if (pllsource != 0)
000030  b115              CBZ      r5,|L22.56|
;;;895          {
;;;896            /* HSE used as PLL clock source */
;;;897            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000032  fbb6f3f3          UDIV     r3,r6,r3
000036  e001              B        |L22.60|
                  |L22.56|
;;;898          }
;;;899          else
;;;900          {
;;;901            /* HSI used as PLL clock source */
;;;902            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000038  fbb4f3f3          UDIV     r3,r4,r3
                  |L22.60|
00003c  680c              LDR      r4,[r1,#0]
;;;903          }
;;;904    
;;;905          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00003e  6809              LDR      r1,[r1,#0]
000040  f3c41488          UBFX     r4,r4,#6,#9           ;902
000044  4363              MULS     r3,r4,r3              ;902
000046  f3c14101          UBFX     r1,r1,#16,#2
00004a  1c49              ADDS     r1,r1,#1
00004c  0049              LSLS     r1,r1,#1
;;;906          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
00004e  fbb3f1f1          UDIV     r1,r3,r1
000052  6001              STR      r1,[r0,#0]
                  |L22.84|
;;;907          break;
;;;908        default:
;;;909          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;910          break;
;;;911      }
;;;912      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;913    
;;;914      /* Get HCLK prescaler */
;;;915      tmp = RCC->CFGR & RCC_CFGR_HPRE;
000054  6811              LDR      r1,[r2,#0]
;;;916      tmp = tmp >> 4;
;;;917      presc = APBAHBPrescTable[tmp];
;;;918      /* HCLK clock frequency */
;;;919      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;920    
;;;921      /* Get PCLK1 prescaler */
;;;922      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;923      tmp = tmp >> 10;
;;;924      presc = APBAHBPrescTable[tmp];
;;;925      /* PCLK1 clock frequency */
;;;926      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;927    
;;;928      /* Get PCLK2 prescaler */
;;;929      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;930      tmp = tmp >> 13;
;;;931      presc = APBAHBPrescTable[tmp];
;;;932      /* PCLK2 clock frequency */
;;;933      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;934    }
000056  230f              MOVS     r3,#0xf
000058  ea031111          AND      r1,r3,r1,LSR #4
00005c  4b0c              LDR      r3,|L22.144|
00005e  5c5c              LDRB     r4,[r3,r1]            ;917
000060  6801              LDR      r1,[r0,#0]            ;919
000062  40e1              LSRS     r1,r1,r4              ;919
000064  6041              STR      r1,[r0,#4]            ;922
000066  6814              LDR      r4,[r2,#0]            ;922
000068  2507              MOVS     r5,#7
00006a  ea052494          AND      r4,r5,r4,LSR #10
00006e  5d1c              LDRB     r4,[r3,r4]            ;924
000070  fa21f404          LSR      r4,r1,r4              ;926
000074  6084              STR      r4,[r0,#8]            ;929
000076  6812              LDR      r2,[r2,#0]            ;929
000078  ea053252          AND      r2,r5,r2,LSR #13
00007c  5c9a              LDRB     r2,[r3,r2]            ;931
00007e  40d1              LSRS     r1,r1,r2              ;933
000080  60c1              STR      r1,[r0,#0xc]          ;933
000082  bd70              POP      {r4-r6,pc}
;;;935    
                          ENDP

                  |L22.132|
                          DCD      0x40023808
                  |L22.136|
                          DCD      0x00f42400
                  |L22.140|
                          DCD      0x017d7840
                  |L22.144|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1700     */
;;;1701   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4602              MOV      r2,r0
;;;1702   {
;;;1703     uint32_t tmp = 0;
;;;1704     uint32_t statusreg = 0;
;;;1705     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1706   
;;;1707     /* Check the parameters */
;;;1708     //assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1709   
;;;1710     /* Get the RCC register index */
;;;1711     tmp = RCC_FLAG >> 5;
000004  0951              LSRS     r1,r2,#5
;;;1712     if (tmp == 1)               /* The flag to check is in CR register */
000006  2901              CMP      r1,#1
000008  d00b              BEQ      |L23.34|
;;;1713     {
;;;1714       statusreg = RCC->CR;
;;;1715     }
;;;1716     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000a  2902              CMP      r1,#2
00000c  d00c              BEQ      |L23.40|
;;;1717     {
;;;1718       statusreg = RCC->BDCR;
;;;1719     }
;;;1720     else                       /* The flag to check is in CSR register */
;;;1721     {
;;;1722       statusreg = RCC->CSR;
00000e  4908              LDR      r1,|L23.48|
                  |L23.16|
000010  6809              LDR      r1,[r1,#0]            ;1718
;;;1723     }
;;;1724   
;;;1725     /* Get the flag position */
;;;1726     tmp = RCC_FLAG & FLAG_MASK;
000012  f002021f          AND      r2,r2,#0x1f
;;;1727     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000016  2301              MOVS     r3,#1
000018  4093              LSLS     r3,r3,r2
00001a  420b              TST      r3,r1
00001c  d000              BEQ      |L23.32|
;;;1728     {
;;;1729       bitstatus = SET;
00001e  2001              MOVS     r0,#1
                  |L23.32|
;;;1730     }
;;;1731     else
;;;1732     {
;;;1733       bitstatus = RESET;
;;;1734     }
;;;1735     /* Return the flag status */
;;;1736     return bitstatus;
;;;1737   }
000020  4770              BX       lr
                  |L23.34|
000022  4903              LDR      r1,|L23.48|
000024  3974              SUBS     r1,r1,#0x74           ;1714
000026  e7f3              B        |L23.16|
                  |L23.40|
000028  4901              LDR      r1,|L23.48|
00002a  1f09              SUBS     r1,r1,#4              ;1718
00002c  e7f0              B        |L23.16|
;;;1738   
                          ENDP

00002e  0000              DCW      0x0000
                  |L23.48|
                          DCD      0x40023874

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1764     */
;;;1765   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L24.16|
;;;1766   {
000002  4601              MOV      r1,r0
;;;1767     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1768   
;;;1769     /* Check the parameters */
;;;1770     //assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1771   
;;;1772     /* Check the status of the specified RCC interrupt */
;;;1773     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L24.14|
;;;1774     {
;;;1775       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L24.14|
;;;1776     }
;;;1777     else
;;;1778     {
;;;1779       bitstatus = RESET;
;;;1780     }
;;;1781     /* Return the RCC_IT status */
;;;1782     return  bitstatus;
;;;1783   }
00000e  4770              BX       lr
;;;1784   
                          ENDP

                  |L24.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;730      */
;;;731    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;732    {
;;;733      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;734    }
000008  4770              BX       lr
;;;735    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;755      */
;;;756    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L26.16|
;;;757    {
;;;758      uint32_t tmpreg = 0;
;;;759      
;;;760      /* Check the parameters */
;;;761      //assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;762    
;;;763      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;764    
;;;765      /* Clear HPRE[3:0] bits */
;;;766      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;767    
;;;768      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;769      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;770    
;;;771      /* Store the new value */
;;;772      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;773    }
00000c  4770              BX       lr
;;;774    
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;252      */
;;;253    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L27.12|
;;;254    {
;;;255      /* Check the parameters */
;;;256      //assert_param(IS_RCC_HSE(RCC_HSE));
;;;257    
;;;258      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;259      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;260    
;;;261      /* Set the new HSE configuration -------------------------------------------*/
;;;262      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  7008              STRB     r0,[r1,#0]
;;;263    }
000008  4770              BX       lr
;;;264    
                          ENDP

00000a  0000              DCW      0x0000
                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;343      */
;;;344    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;345    {
;;;346      /* Check the parameters */
;;;347      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;348    
;;;349      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;350    }
000004  4770              BX       lr
;;;351    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1061     */
;;;1062   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1063   {
;;;1064     /* Check the parameters */
;;;1065     //assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1066   
;;;1067     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  f8c1015c          STR      r0,[r1,#0x15c]
;;;1068   }
000006  4770              BX       lr
;;;1069   
                          ENDP

                  |L29.8|
                          DCD      0x42470000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1664     */
;;;1665   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L30.20|
;;;1666   {
;;;1667     /* Check the parameters */
;;;1668     //assert_param(IS_RCC_IT(RCC_IT));
;;;1669     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1670     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1671     {
;;;1672       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1673       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;1674     }
;;;1675     else
;;;1676     {
;;;1677       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1678       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7811              LDRB     r1,[r2,#0]
000006  d001              BEQ      |L30.12|
000008  4301              ORRS     r1,r1,r0              ;1673
00000a  e000              B        |L30.14|
                  |L30.12|
00000c  4381              BICS     r1,r1,r0
                  |L30.14|
00000e  7011              STRB     r1,[r2,#0]            ;1673
;;;1679     }
;;;1680   }
000010  4770              BX       lr
;;;1681   
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;368      */
;;;369    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4905              LDR      r1,|L31.24|
;;;370    {
;;;371      /* Check the parameters */
;;;372      //assert_param(IS_RCC_LSE(RCC_LSE));
;;;373    
;;;374      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;375      /* Reset LSEON bit */
;;;376      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;377    
;;;378      /* Reset LSEBYP bit */
;;;379      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  700a              STRB     r2,[r1,#0]
;;;380    
;;;381      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;382      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L31.18|
00000c  2804              CMP      r0,#4
00000e  d101              BNE      |L31.20|
;;;383      {
;;;384        case RCC_LSE_ON:
;;;385          /* Set LSEON bit */
;;;386          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;387          break;
;;;388        case RCC_LSE_Bypass:
;;;389          /* Set LSEBYP and LSEON bits */
;;;390          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000010  2005              MOVS     r0,#5
                  |L31.18|
000012  7008              STRB     r0,[r1,#0]
                  |L31.20|
;;;391          break;
;;;392        default:
;;;393          break;
;;;394      }
;;;395    }
000014  4770              BX       lr
;;;396    
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;408      */
;;;409    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;410    {
;;;411      /* Check the parameters */
;;;412      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;413    
;;;414      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;415    }
000004  4770              BX       lr
;;;416    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;558      */
;;;559    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4a03              LDR      r2,|L33.16|
;;;560    {
;;;561      uint32_t tmpreg = 0;
;;;562      
;;;563      /* Check the parameters */
;;;564      //assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;565      //assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;566    
;;;567      tmpreg = RCC->CFGR;
000002  6813              LDR      r3,[r2,#0]
;;;568    
;;;569      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;570      tmpreg &= CFGR_MCO1_RESET_MASK;
;;;571    
;;;572      /* Select MCO1 clock source and prescaler */
;;;573      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
000004  4308              ORRS     r0,r0,r1
000006  f02363ec          BIC      r3,r3,#0x7600000      ;570
00000a  4318              ORRS     r0,r0,r3
;;;574    
;;;575      /* Store the new value */
;;;576      RCC->CFGR = tmpreg;  
00000c  6010              STR      r0,[r2,#0]
;;;577    }
00000e  4770              BX       lr
;;;578    
                          ENDP

                  |L33.16|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;596      */
;;;597    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4a03              LDR      r2,|L34.16|
;;;598    {
;;;599      uint32_t tmpreg = 0;
;;;600      
;;;601      /* Check the parameters */
;;;602      //assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;603      //assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;604      
;;;605      tmpreg = RCC->CFGR;
000002  6813              LDR      r3,[r2,#0]
;;;606      
;;;607      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;608      tmpreg &= CFGR_MCO2_RESET_MASK;
;;;609    
;;;610      /* Select MCO2 clock source and prescaler */
;;;611      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000004  4308              ORRS     r0,r0,r1
000006  f0234378          BIC      r3,r3,#0xf8000000     ;608
00000a  4318              ORRS     r0,r0,r3
;;;612    
;;;613      /* Store the new value */
;;;614      RCC->CFGR = tmpreg;  
00000c  6010              STR      r0,[r2,#0]
;;;615    }
00000e  4770              BX       lr
;;;616    
                          ENDP

                  |L34.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;787      */
;;;788    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L35.16|
;;;789    {
;;;790      uint32_t tmpreg = 0;
;;;791    
;;;792      /* Check the parameters */
;;;793      //assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;794    
;;;795      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;796    
;;;797      /* Clear PPRE1[2:0] bits */
;;;798      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42151e0          BIC      r1,r1,#0x1c00
;;;799    
;;;800      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;801      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;802    
;;;803      /* Store the new value */
;;;804      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;805    }
00000c  4770              BX       lr
;;;806    
                          ENDP

00000e  0000              DCW      0x0000
                  |L35.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;818      */
;;;819    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4903              LDR      r1,|L36.16|
;;;820    {
;;;821      uint32_t tmpreg = 0;
;;;822    
;;;823      /* Check the parameters */
;;;824      //assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;825    
;;;826      tmpreg = RCC->CFGR;
000002  680a              LDR      r2,[r1,#0]
;;;827    
;;;828      /* Clear PPRE2[2:0] bits */
;;;829      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4224260          BIC      r2,r2,#0xe000
;;;830    
;;;831      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;832      tmpreg |= RCC_HCLK << 3;
000008  ea4200c0          ORR      r0,r2,r0,LSL #3
;;;833    
;;;834      /* Store the new value */
;;;835      RCC->CFGR = tmpreg;
00000c  6008              STR      r0,[r1,#0]
;;;836    }
00000e  4770              BX       lr
;;;837    
                          ENDP

                  |L36.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;474      */
;;;475    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L37.8|
;;;476    {
;;;477      /* Check the parameters */
;;;478      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;480    }
000004  4770              BX       lr
;;;481    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;451      */
;;;452    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  ea411182          ORR      r1,r1,r2,LSL #6
;;;453    {
;;;454      /* Check the parameters */
;;;455      //assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;456      //assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;457      //assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;458      //assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;459      //assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;460    
;;;461      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  085a              LSRS     r2,r3,#1
000006  b510              PUSH     {r4,lr}               ;453
000008  4b05              LDR      r3,|L38.32|
00000a  9c02              LDR      r4,[sp,#8]
00000c  eb034202          ADD      r2,r3,r2,LSL #16
000010  4311              ORRS     r1,r1,r2
000012  4301              ORRS     r1,r1,r0
000014  ea416004          ORR      r0,r1,r4,LSL #24
000018  4902              LDR      r1,|L38.36|
00001a  6008              STR      r0,[r1,#0]
;;;462                     (PLLQ << 24);
;;;463    }
00001c  bd10              POP      {r4,pc}
;;;464    
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      0xffff0000
                  |L38.36|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;515      */
;;;516    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L39.8|
;;;517    {
;;;518      /* Check the parameters */
;;;519      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;520      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;521    }
000004  4770              BX       lr
;;;522    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;500      */
;;;501    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0180              LSLS     r0,r0,#6
;;;502    {
;;;503      /* Check the parameters */
;;;504      //assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;505      //assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;506    
;;;507      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea407001          ORR      r0,r0,r1,LSL #28
000006  4901              LDR      r1,|L40.12|
000008  6008              STR      r0,[r1,#0]
;;;508    }
00000a  4770              BX       lr
;;;509    
                          ENDP

                  |L40.12|
                          DCD      0x40023884

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1027     */
;;;1028   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L41.8|
;;;1029   {
;;;1030     /* Check the parameters */
;;;1031     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1032   
;;;1033     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1034   }
000004  4770              BX       lr
;;;1035   
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;995      */
;;;996    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  f3c02101          UBFX     r1,r0,#8,#2
;;;997    {
;;;998      uint32_t tmpreg = 0;
;;;999    
;;;1000     /* Check the parameters */
;;;1001     //assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;1002   
;;;1003     if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000004  2903              CMP      r1,#3
000006  d107              BNE      |L42.24|
;;;1004     { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;1005       tmpreg = RCC->CFGR;
000008  4a07              LDR      r2,|L42.40|
00000a  6811              LDR      r1,[r2,#0]
;;;1006   
;;;1007       /* Clear RTCPRE[4:0] bits */
;;;1008       tmpreg &= ~RCC_CFGR_RTCPRE;
00000c  f42113f8          BIC      r3,r1,#0x1f0000
;;;1009   
;;;1010       /* Configure HSE division factor for RTC clock */
;;;1011       tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
000010  4906              LDR      r1,|L42.44|
000012  4001              ANDS     r1,r1,r0
000014  4319              ORRS     r1,r1,r3
;;;1012   
;;;1013       /* Store the new value */
;;;1014       RCC->CFGR = tmpreg;
000016  6011              STR      r1,[r2,#0]
                  |L42.24|
;;;1015     }
;;;1016       
;;;1017     /* Select the RTC clock source */
;;;1018     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
000018  4903              LDR      r1,|L42.40|
00001a  3168              ADDS     r1,r1,#0x68
00001c  680a              LDR      r2,[r1,#0]
00001e  f3c0000b          UBFX     r0,r0,#0,#12
000022  4302              ORRS     r2,r2,r0
000024  600a              STR      r2,[r1,#0]
;;;1019   }
000026  4770              BX       lr
;;;1020   
                          ENDP

                  |L42.40|
                          DCD      0x40023808
                  |L42.44|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;702      */
;;;703    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L43.16|
;;;704    {
;;;705      uint32_t tmpreg = 0;
;;;706    
;;;707      /* Check the parameters */
;;;708      //assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;709    
;;;710      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;711    
;;;712      /* Clear SW[1:0] bits */
;;;713      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;714    
;;;715      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;716      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;717    
;;;718      /* Store the new value */
;;;719      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;720    }
00000c  4770              BX       lr
;;;721    
                          ENDP

00000e  0000              DCW      0x0000
                  |L43.16|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;276      */
;;;277    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;278    {
;;;279      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
;;;280      ErrorStatus status = ERROR;
;;;281      FlagStatus hsestatus = RESET;
;;;282      /* Wait till HSE is ready and if Time out is reached exit */
;;;283      do
;;;284      {
;;;285        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;286        startupcounter++;
;;;287      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L44.10|
00000a  2031              MOVS     r0,#0x31              ;285
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;286
000012  1c49              ADDS     r1,r1,#1              ;286
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L44.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L44.10|
                  |L44.30|
;;;288    
;;;289      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  b108              CBZ      r0,|L44.42|
;;;290      {
;;;291        status = SUCCESS;
000026  2000              MOVS     r0,#0
;;;292      }
;;;293      else
;;;294      {
;;;295        status = ERROR;
;;;296      }
;;;297      return (status);
;;;298    }
000028  bd18              POP      {r3,r4,pc}
                  |L44.42|
00002a  2001              MOVS     r0,#1                 ;295
00002c  bd18              POP      {r3,r4,pc}
;;;299    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "drivers\\stm32f4xx_rcc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 223
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____RRX|
#line 410
|__asm___15_stm32f4xx_rcc_c_49e27980____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
