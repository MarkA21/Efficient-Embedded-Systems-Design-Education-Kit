; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\uart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\uart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\uart.crf drivers\uart.c]
                          THUMB

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;91     
;;;92     void USART2_IRQHandler(void){
000000  b510              PUSH     {r4,lr}
;;;93     	NVIC_ClearPendingIRQ(USART2_IRQn);
000002  2026              MOVS     r0,#0x26
000004  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;94     	if (READ_BIT(USART2->SR, USART_SR_RXNE)) {
000008  4805              LDR      r0,|L1.32|
00000a  6800              LDR      r0,[r0,#0]
00000c  0680              LSLS     r0,r0,#26
00000e  d506              BPL      |L1.30|
;;;95     		// received a character
;;;96     		UART_callback(uart_rx());
000010  f7fffffe          BL       uart_rx
000014  4903              LDR      r1,|L1.36|
000016  6809              LDR      r1,[r1,#0]  ; UART_callback
000018  e8bd4010          POP      {r4,lr}
00001c  4708              BX       r1
                  |L1.30|
;;;97     	}
;;;98     }
00001e  bd10              POP      {r4,pc}
;;;99     
                          ENDP

                  |L1.32|
                          DCD      0x40004400
                  |L1.36|
                          DCD      ||.data||

                          AREA ||i.__NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_ClearPendingIRQ PROC
;;;1774    */
;;;1775   __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1776   {
000002  db09              BLT      |L2.24|
;;;1777     if ((int32_t)(IRQn) >= 0)
;;;1778     {
;;;1779       NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01280          STR      r1,[r0,#0x280]
                  |L2.24|
;;;1780     }
;;;1781   }
000018  4770              BX       lr
;;;1782   
                          ENDP


                          AREA ||i.uart_enable||, CODE, READONLY, ALIGN=2

                  uart_enable PROC
;;;47     
;;;48     void uart_enable(void) {
000000  2101              MOVS     r1,#1
;;;49     	USART_Cmd(USART2, ENABLE);
000002  4801              LDR      r0,|L3.8|
000004  f7ffbffe          B.W      USART_Cmd
;;;50     }
;;;51     
                          ENDP

                  |L3.8|
                          DCD      0x40004400

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;8      
;;;9      void uart_init(uint32_t baud) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4606              MOV      r6,r0
;;;10     	GPIO_InitTypeDef GPIO_InitStructure;
;;;11     	USART_InitTypeDef USART_InitStructure;
;;;12     	
;;;13     	/* --------------------------- System Clocks Configuration -----------------*/
;;;14       /* USART2 clock enable */
;;;15       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
000004  2101              MOVS     r1,#1
000006  b087              SUB      sp,sp,#0x1c           ;9
000008  0448              LSLS     r0,r1,#17
00000a  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;16       /* GPIOA clock enable */
;;;17       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
00000e  2101              MOVS     r1,#1
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;18     	
;;;19       /*-------------------------- GPIO Configuration ----------------------------*/
;;;20       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3; // PA.2 USART2_TX, PA.3 USART2_RX
;;;21       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000016  2002              MOVS     r0,#2
000018  f88d0014          STRB     r0,[sp,#0x14]
;;;22       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001c  2400              MOVS     r4,#0
00001e  f88d4016          STRB     r4,[sp,#0x16]
;;;23       GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
;;;24       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;25       GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  4f13              LDR      r7,|L4.112|
000024  250c              MOVS     r5,#0xc               ;20
000026  f88d4017          STRB     r4,[sp,#0x17]         ;23
00002a  9504              STR      r5,[sp,#0x10]         ;21
00002c  f88d4015          STRB     r4,[sp,#0x15]         ;24
000030  a904              ADD      r1,sp,#0x10
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       GPIO_Init
;;;26       /* Connect USART pins to AF */
;;;27       GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
000038  2207              MOVS     r2,#7
00003a  2102              MOVS     r1,#2
00003c  4638              MOV      r0,r7
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;28       GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);
000042  2207              MOVS     r2,#7
000044  2103              MOVS     r1,#3
000046  4638              MOV      r0,r7
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;29     	
;;;30       /* USARTx configuration ------------------------------------------------------*/
;;;31       /* USARTx configured as follow:
;;;32             - BaudRate = 115200 baud
;;;33             - Word Length = 8 Bits
;;;34             - One Stop Bit
;;;35             - No parity
;;;36             - Hardware flow control disabled (RTS and CTS signals)
;;;37             - Receive and transmit enabled
;;;38       */
;;;39       USART_InitStructure.USART_BaudRate = baud;
;;;40       USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  f8ad4004          STRH     r4,[sp,#4]
;;;41       USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;42       USART_InitStructure.USART_Parity = USART_Parity_No;
000050  f8ad4008          STRH     r4,[sp,#8]
000054  9600              STR      r6,[sp,#0]            ;40
000056  f8ad4006          STRH     r4,[sp,#6]            ;41
;;;43       USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad400c          STRH     r4,[sp,#0xc]
;;;44       USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  f8ad500a          STRH     r5,[sp,#0xa]
;;;45       USART_Init(USART2, &USART_InitStructure);
000062  4669              MOV      r1,sp
000064  4803              LDR      r0,|L4.116|
000066  f7fffffe          BL       USART_Init
;;;46     }
00006a  b007              ADD      sp,sp,#0x1c
00006c  bdf0              POP      {r4-r7,pc}
;;;47     
                          ENDP

00006e  0000              DCW      0x0000
                  |L4.112|
                          DCD      0x40020000
                  |L4.116|
                          DCD      0x40004400

                          AREA ||i.uart_print||, CODE, READONLY, ALIGN=1

                  uart_print PROC
;;;51     
;;;52     void uart_print(char *string) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;53     	while(*string) {
;;;54         uart_tx(*string++);
000004  e002              B        |L5.12|
                  |L5.6|
000006  1c64              ADDS     r4,r4,#1
000008  f7fffffe          BL       uart_tx
                  |L5.12|
00000c  7820              LDRB     r0,[r4,#0]            ;53
00000e  2800              CMP      r0,#0                 ;53
000010  d1f9              BNE      |L5.6|
;;;55       }
;;;56     }
000012  bd10              POP      {r4,pc}
;;;57     
                          ENDP


                          AREA ||i.uart_rx||, CODE, READONLY, ALIGN=2

                  uart_rx PROC
;;;83     
;;;84     uint8_t uart_rx(void) {
000000  b510              PUSH     {r4,lr}
;;;85     	uint16_t Data;
;;;86     	while(USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET) {
000002  4c06              LDR      r4,|L6.28|
                  |L6.4|
000004  2120              MOVS     r1,#0x20
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L6.4|
;;;87     	}		// Wait for Char
;;;88     	Data = USART_ReceiveData(USART2); // Collect Char
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       USART_ReceiveData
;;;89     	return Data;
000016  b2c0              UXTB     r0,r0
;;;90     }
000018  bd10              POP      {r4,pc}
;;;91     
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40004400

                          AREA ||i.uart_set_rx_callback||, CODE, READONLY, ALIGN=2

                  uart_set_rx_callback PROC
;;;57     
;;;58     void uart_set_rx_callback(void (*callback)(uint8_t)) {
000000  490a              LDR      r1,|L7.44|
000002  b510              PUSH     {r4,lr}
;;;59     	// Set up and enable the interrupt.
;;;60     	
;;;61     	// The callback function should be stored in an internal
;;;62     	// static function pointer.
;;;63     	
;;;64     	// Whenever a character is received by the UART peripheral,
;;;65     	// the callback function should be executed with the
;;;66     	// parameter equalling the received character.
;;;67     	
;;;68     	UART_callback = callback;
;;;69     	USART2->CR1|=USART_CR1_RXNEIE;
000004  6008              STR      r0,[r1,#0]  ; UART_callback
000006  480a              LDR      r0,|L7.48|
000008  6801              LDR      r1,[r0,#0]
00000a  f0410120          ORR      r1,r1,#0x20
00000e  6001              STR      r1,[r0,#0]
;;;70     	
;;;71     	//Enable the USART interrupt
;;;72     	__enable_irq();
000010  b662              CPSIE    i
000012  2000              MOVS     r0,#0
000014  4907              LDR      r1,|L7.52|
000016  f8810400          STRB     r0,[r1,#0x400]
;;;73     	NVIC_SetPriority(USART2_IRQn,0);
;;;74     	NVIC_ClearPendingIRQ(USART2_IRQn);
00001a  2026              MOVS     r0,#0x26
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
000020  4904              LDR      r1,|L7.52|
000022  2040              MOVS     r0,#0x40
000024  3922              SUBS     r1,r1,#0x22
000026  f8c10100          STR      r0,[r1,#0x100]
;;;75     	NVIC_EnableIRQ(USART2_IRQn);
;;;76     }
00002a  bd10              POP      {r4,pc}
;;;77     
                          ENDP

                  |L7.44|
                          DCD      ||.data||
                  |L7.48|
                          DCD      0x4000440c
                  |L7.52|
                          DCD      0xe000e026

                          AREA ||i.uart_tx||, CODE, READONLY, ALIGN=2

                  uart_tx PROC
;;;77     
;;;78     void uart_tx(uint8_t c) {
000000  b570              PUSH     {r4-r6,lr}
;;;79     	while(USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET) {
000002  4c07              LDR      r4,|L8.32|
000004  4605              MOV      r5,r0                 ;78
                  |L8.6|
000006  2180              MOVS     r1,#0x80
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L8.6|
;;;80     	}		// Wait for Empty
;;;81       USART_SendData(USART2, c); // Echo Char
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  e8bd4070          POP      {r4-r6,lr}
00001a  f7ffbffe          B.W      USART_SendData
;;;82     }
;;;83     
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      0x40004400

                          AREA ||.data||, DATA, ALIGN=2

                  UART_callback
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "drivers\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f64bdfb6____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____REVSH|
#line 223
|__asm___6_uart_c_f64bdfb6____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f64bdfb6____RRX|
#line 410
|__asm___6_uart_c_f64bdfb6____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
