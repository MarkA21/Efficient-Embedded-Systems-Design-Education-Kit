; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_usart.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\stm32f4xx_usart.crf drivers\stm32f4xx_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;1320     */
;;;1321   void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  43c9              MVNS     r1,r1
;;;1322   {
;;;1323     /* Check the parameters */
;;;1324     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1325     //assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;1326   
;;;1327     /* The CTS flag is not available for UART4 and UART5 */
;;;1328     if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
;;;1329     {
;;;1330       //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1331     } 
;;;1332          
;;;1333     USARTx->SR = (uint16_t)~USART_FLAG;
000002  b289              UXTH     r1,r1
000004  6001              STR      r1,[r0,#0]
;;;1334   }
000006  4770              BX       lr
;;;1335   
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1428     */
;;;1429   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  0a0a              LSRS     r2,r1,#8
;;;1430   {
;;;1431     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1432     /* Check the parameters */
;;;1433     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1434     //assert_param(IS_USART_CLEAR_IT(USART_IT)); 
;;;1435   
;;;1436     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1437     if (USART_IT == USART_IT_CTS)
;;;1438     {
;;;1439       //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1440     } 
;;;1441       
;;;1442     bitpos = USART_IT >> 0x08;
;;;1443     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000002  2101              MOVS     r1,#1
000004  4091              LSLS     r1,r1,r2
;;;1444     USARTx->SR = (uint16_t)~itmask;
000006  43c9              MVNS     r1,r1
000008  b289              UXTH     r1,r1
00000a  6001              STR      r1,[r0,#0]
;;;1445   }
00000c  4770              BX       lr
;;;1446   
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;359      */
;;;360    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;361    {
;;;362      uint32_t tmpreg = 0x00;
;;;363    //  /* Check the parameters */
;;;364    //  //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;365    //  //assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;366    //  //assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;367    //  //assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;368    //  //assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;369      
;;;370    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;371      tmpreg = USARTx->CR2;
000002  6902              LDR      r2,[r0,#0x10]
;;;372      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;373      tmpreg &= (uint32_t)~((uint32_t)CR2_CLOCK_CLEAR_MASK);
;;;374      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;375      /* Set CLKEN bit according to USART_Clock value */
;;;376      /* Set CPOL bit according to USART_CPOL value */
;;;377      /* Set CPHA bit according to USART_CPHA value */
;;;378      /* Set LBCL bit according to USART_LastBit value */
;;;379      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
000004  884c              LDRH     r4,[r1,#2]
000006  f4226370          BIC      r3,r2,#0xf00          ;373
00000a  880a              LDRH     r2,[r1,#0]
00000c  4322              ORRS     r2,r2,r4
00000e  888c              LDRH     r4,[r1,#4]
000010  88c9              LDRH     r1,[r1,#6]
000012  430c              ORRS     r4,r4,r1
000014  4322              ORRS     r2,r2,r4
000016  431a              ORRS     r2,r2,r3
;;;380                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;381      /* Write to USART CR2 */
;;;382      USARTx->CR2 = (uint16_t)tmpreg;
000018  b291              UXTH     r1,r2
00001a  6101              STR      r1,[r0,#0x10]
;;;383    }
00001c  bd10              POP      {r4,pc}
;;;384    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;390      */
;;;391    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;392    {
;;;393      /* USART_ClockInitStruct members default value */
;;;394      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;395      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;396      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;397      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;398    }
00000a  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;407      */
;;;408    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;409    {
;;;410    //  /* Check the parameters */
;;;411    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;412    //  //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;413      
;;;414      if (NewState != DISABLE)
;;;415      {
;;;416        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;417        USARTx->CR1 |= USART_CR1_UE;
;;;418      }
;;;419      else
;;;420      {
;;;421        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;422        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_UE);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L5.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;417
00000a  e002              B        |L5.18|
                  |L5.12|
00000c  f64d72ff          MOV      r2,#0xdfff
000010  4011              ANDS     r1,r1,r2
                  |L5.18|
000012  60c1              STR      r1,[r0,#0xc]          ;417
;;;423      }
;;;424    }
000014  4770              BX       lr
;;;425    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;1079     */
;;;1080   void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;1081   {
;;;1082     /* Check the parameters */
;;;1083     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1084     //assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;1085     //assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;1086   
;;;1087     if (NewState != DISABLE)
;;;1088     {
;;;1089       /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;1090          DMAR bits in the USART CR3 register */
;;;1091       USARTx->CR3 |= USART_DMAReq;
;;;1092     }
;;;1093     else
;;;1094     {
;;;1095       /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;1096          DMAR bits in the USART CR3 register */
;;;1097       USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000002  6942              LDR      r2,[r0,#0x14]
000004  d001              BEQ      |L6.10|
000006  430a              ORRS     r2,r2,r1              ;1091
000008  e002              B        |L6.16|
                  |L6.10|
00000a  43c9              MVNS     r1,r1
00000c  b289              UXTH     r1,r1
00000e  400a              ANDS     r2,r2,r1
                  |L6.16|
000010  6142              STR      r2,[r0,#0x14]         ;1091
;;;1098     }
;;;1099   }
000012  4770              BX       lr
;;;1100   
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;177      */
;;;178    void USART_DeInit(USART_TypeDef* USARTx)
000000  4913              LDR      r1,|L7.80|
;;;179    {
000002  b510              PUSH     {r4,lr}
;;;180      /* Check the parameters */
;;;181      ////assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;182    
;;;183      if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d106              BNE      |L7.22|
;;;184      {
;;;185        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  2010              MOVS     r0,#0x10
00000c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;186        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000010  2100              MOVS     r1,#0
000012  2010              MOVS     r0,#0x10
000014  e016              B        |L7.68|
                  |L7.22|
;;;187      }
;;;188      else if (USARTx == USART2)
000016  490f              LDR      r1,|L7.84|
000018  4288              CMP      r0,r1
00001a  d10a              BNE      |L7.50|
;;;189      {
;;;190        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  044c              LSLS     r4,r1,#17
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;191        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000026  4620              MOV      r0,r4
000028  e8bd4010          POP      {r4,lr}
00002c  2100              MOVS     r1,#0
00002e  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.50|
;;;192      }
;;;193    //  else if (USARTx == USART3)
;;;194    //  {
;;;195    //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
;;;196    //   RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
;;;197    //  }    
;;;198    // else if (USARTx == UART4)
;;;199    //  {
;;;200    //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
;;;201    //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
;;;202    //  }
;;;203    //  else if (USARTx == UART5)
;;;204    //  {
;;;205    //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
;;;206    //    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
;;;207    //  }     
;;;208      else
;;;209      {
;;;210        if (USARTx == USART6)
000032  4909              LDR      r1,|L7.88|
000034  4288              CMP      r0,r1
000036  d109              BNE      |L7.76|
;;;211        { 
;;;212          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, ENABLE);
000038  2101              MOVS     r1,#1
00003a  2020              MOVS     r0,#0x20
00003c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;213          RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART6, DISABLE);
000040  2100              MOVS     r1,#0
000042  2020              MOVS     r0,#0x20
                  |L7.68|
000044  e8bd4010          POP      {r4,lr}
000048  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.76|
;;;214        }
;;;215      }
;;;216    }
00004c  bd10              POP      {r4,pc}
;;;217    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0x40011000
                  |L7.84|
                          DCD      0x40004400
                  |L7.88|
                          DCD      0x40011400

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;1271     */
;;;1272   FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;1273   {
;;;1274     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1275     /* Check the parameters */
;;;1276     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1277     //assert_param(IS_USART_FLAG(USART_FLAG));
;;;1278   
;;;1279     /* The CTS flag is not available for UART4 and UART5 */
;;;1280     if (USART_FLAG == USART_FLAG_CTS)
;;;1281     {
;;;1282       //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1283     } 
;;;1284       
;;;1285     if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;1286     {
;;;1287       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;1288     }
;;;1289     else
;;;1290     {
;;;1291       bitstatus = RESET;
;;;1292     }
;;;1293     return bitstatus;
;;;1294   }
00000c  4770              BX       lr
;;;1295   
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;1354     */
;;;1355   ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1356   {
;;;1357     uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;1358     ITStatus bitstatus = RESET;
;;;1359     /* Check the parameters */
;;;1360     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1361     //assert_param(IS_USART_GET_IT(USART_IT)); 
;;;1362   
;;;1363     /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;1364     if (USART_IT == USART_IT_CTS)
;;;1365     {
;;;1366       //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1367     } 
;;;1368       
;;;1369     /* Get the USART register index */
;;;1370     usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;1371     /* Get the interrupt position */
;;;1372     itmask = USART_IT & IT_MASK;
000002  f001021f          AND      r2,r1,#0x1f
;;;1373     itmask = (uint32_t)0x01 << itmask;
000006  2401              MOVS     r4,#1
000008  2500              MOVS     r5,#0                 ;1358
00000a  f3c11342          UBFX     r3,r1,#5,#3           ;1370
00000e  fa04f202          LSL      r2,r4,r2
;;;1374     
;;;1375     if (usartreg == 0x01) /* The IT  is in CR1 register */
000012  2b01              CMP      r3,#1
000014  d00f              BEQ      |L9.54|
;;;1376     {
;;;1377       itmask &= USARTx->CR1;
;;;1378     }
;;;1379     else if (usartreg == 0x02) /* The IT  is in CR2 register */
000016  2b02              CMP      r3,#2
000018  d00f              BEQ      |L9.58|
;;;1380     {
;;;1381       itmask &= USARTx->CR2;
;;;1382     }
;;;1383     else /* The IT  is in CR3 register */
;;;1384     {
;;;1385       itmask &= USARTx->CR3;
00001a  6943              LDR      r3,[r0,#0x14]
                  |L9.28|
;;;1386     }
;;;1387     
;;;1388     bitpos = USART_IT >> 0x08;
00001c  ea4f2111          LSR      r1,r1,#8
;;;1389     bitpos = (uint32_t)0x01 << bitpos;
;;;1390     bitpos &= USARTx->SR;
000020  6800              LDR      r0,[r0,#0]
000022  4213              TST      r3,r2                 ;1381
000024  fa04f401          LSL      r4,r4,r1              ;1389
000028  ea000004          AND      r0,r0,r4
00002c  d001              BEQ      |L9.50|
;;;1391     if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00002e  b100              CBZ      r0,|L9.50|
;;;1392     {
;;;1393       bitstatus = SET;
000030  2501              MOVS     r5,#1
                  |L9.50|
;;;1394     }
;;;1395     else
;;;1396     {
;;;1397       bitstatus = RESET;
;;;1398     }
;;;1399     
;;;1400     return bitstatus;  
000032  4628              MOV      r0,r5
;;;1401   }
000034  bd30              POP      {r4,r5,pc}
                  |L9.54|
000036  68c3              LDR      r3,[r0,#0xc]          ;1377
000038  e7f0              B        |L9.28|
                  |L9.58|
00003a  6903              LDR      r3,[r0,#0x10]         ;1381
00003c  e7ee              B        |L9.28|
;;;1402   
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;815      */
;;;816    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;817    {
;;;818      /* Check the parameters */
;;;819      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;820      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;821      
;;;822      if (NewState != DISABLE)
;;;823      {
;;;824        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;825        USARTx->CR3 |= USART_CR3_HDSEL;
;;;826      }
;;;827      else
;;;828      {
;;;829        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;830        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_HDSEL);
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L10.12|
000006  f0410108          ORR      r1,r1,#8              ;825
00000a  e002              B        |L10.18|
                  |L10.12|
00000c  f64f72f7          MOV      r2,#0xfff7
000010  4011              ANDS     r1,r1,r2
                  |L10.18|
000012  6141              STR      r1,[r0,#0x14]         ;825
;;;831      }
;;;832    }
000014  4770              BX       lr
;;;833    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;1207     */
;;;1208   void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1209   {
;;;1210     uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;1211     uint32_t usartxbase = 0x00;
;;;1212     /* Check the parameters */
;;;1213     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1214     //assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;1215     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1216   
;;;1217     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1218     if (USART_IT == USART_IT_CTS)
;;;1219     {
;;;1220       //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;1221     } 
;;;1222       
;;;1223     usartxbase = (uint32_t)USARTx;
;;;1224   
;;;1225     /* Get the USART register index */
;;;1226     usartreg = (((uint8_t)USART_IT) >> 0x05);
000002  f3c11342          UBFX     r3,r1,#5,#3
;;;1227   
;;;1228     /* Get the interrupt position */
;;;1229     itpos = USART_IT & IT_MASK;
000006  f001041f          AND      r4,r1,#0x1f
;;;1230     itmask = (((uint32_t)0x01) << itpos);
00000a  2101              MOVS     r1,#1
00000c  40a1              LSLS     r1,r1,r4
;;;1231       
;;;1232     if (usartreg == 0x01) /* The IT is in CR1 register */
00000e  2b01              CMP      r3,#1
000010  d007              BEQ      |L11.34|
;;;1233     {
;;;1234       usartxbase += 0x0C;
;;;1235     }
;;;1236     else if (usartreg == 0x02) /* The IT is in CR2 register */
000012  2b02              CMP      r3,#2
000014  d007              BEQ      |L11.38|
000016  3014              ADDS     r0,r0,#0x14
                  |L11.24|
;;;1237     {
;;;1238       usartxbase += 0x10;
;;;1239     }
;;;1240     else /* The IT is in CR3 register */
;;;1241     {
;;;1242       usartxbase += 0x14; 
;;;1243     }
;;;1244     if (NewState != DISABLE)
000018  2a00              CMP      r2,#0
;;;1245     {
;;;1246       *(__IO uint32_t*)usartxbase  |= itmask;
;;;1247     }
;;;1248     else
;;;1249     {
;;;1250       *(__IO uint32_t*)usartxbase &= ~itmask;
00001a  6802              LDR      r2,[r0,#0]
00001c  d005              BEQ      |L11.42|
00001e  430a              ORRS     r2,r2,r1              ;1246
000020  e004              B        |L11.44|
                  |L11.34|
000022  300c              ADDS     r0,r0,#0xc            ;1246
000024  e7f8              B        |L11.24|
                  |L11.38|
000026  3010              ADDS     r0,r0,#0x10           ;1234
000028  e7f6              B        |L11.24|
                  |L11.42|
00002a  438a              BICS     r2,r2,r1
                  |L11.44|
00002c  6002              STR      r2,[r0,#0]            ;1246
;;;1251     }
;;;1252   }
00002e  bd10              POP      {r4,pc}
;;;1253   
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;226      */
;;;227    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b57f              PUSH     {r0-r6,lr}
;;;228    {
000002  4604              MOV      r4,r0
;;;229      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;230      uint32_t integerdivider = 0x00;
;;;231      uint32_t fractionaldivider = 0x00;
;;;232      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;233    
;;;234    //  /* Check the parameters */
;;;235    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;236    //  //assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;237    //  //assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;238    //  //assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;239    //  //assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;240    //  //assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;241    //  //assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;242    
;;;243      /* The hardware flow control is available only for USART1, USART2, USART3 and USART6 */
;;;244      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
;;;245      {
;;;246    //    //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;247      }
;;;248    
;;;249    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;250      tmpreg = USARTx->CR2;
000004  6900              LDR      r0,[r0,#0x10]
000006  460d              MOV      r5,r1                 ;228
;;;251    
;;;252      /* Clear STOP[13:12] bits */
;;;253      tmpreg &= (uint32_t)~((uint32_t)USART_CR2_STOP);
000008  f4205140          BIC      r1,r0,#0x3000
;;;254    
;;;255      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit :
;;;256          Set STOP[13:12] bits according to USART_StopBits value */
;;;257      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
00000c  88e8              LDRH     r0,[r5,#6]
00000e  4308              ORRS     r0,r0,r1
;;;258      
;;;259      /* Write to USART CR2 */
;;;260      USARTx->CR2 = (uint16_t)tmpreg;
000010  b280              UXTH     r0,r0
000012  6120              STR      r0,[r4,#0x10]
;;;261    
;;;262    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;263      tmpreg = USARTx->CR1;
000014  68e1              LDR      r1,[r4,#0xc]
;;;264    
;;;265      /* Clear M, PCE, PS, TE and RE bits */
;;;266      tmpreg &= (uint32_t)~((uint32_t)CR1_CLEAR_MASK);
000016  f241600c          MOV      r0,#0x160c
00001a  4381              BICS     r1,r1,r0
;;;267    
;;;268      /* Configure the USART Word Length, Parity and mode: 
;;;269         Set the M bits according to USART_WordLength value 
;;;270         Set PCE and PS bits according to USART_Parity value
;;;271         Set TE and RE bits according to USART_Mode value */
;;;272      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00001c  88a8              LDRH     r0,[r5,#4]
00001e  892a              LDRH     r2,[r5,#8]
000020  4310              ORRS     r0,r0,r2
000022  896a              LDRH     r2,[r5,#0xa]
000024  430a              ORRS     r2,r2,r1
000026  4310              ORRS     r0,r0,r2
;;;273                USART_InitStruct->USART_Mode;
;;;274    
;;;275      /* Write to USART CR1 */
;;;276      USARTx->CR1 = (uint16_t)tmpreg;
000028  b280              UXTH     r0,r0
00002a  60e0              STR      r0,[r4,#0xc]
;;;277    
;;;278    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;279      tmpreg = USARTx->CR3;
00002c  6960              LDR      r0,[r4,#0x14]
;;;280    
;;;281      /* Clear CTSE and RTSE bits */
;;;282      tmpreg &= (uint32_t)~((uint32_t)CR3_CLEAR_MASK);
00002e  f4207140          BIC      r1,r0,#0x300
;;;283    
;;;284      /* Configure the USART HFC : 
;;;285          Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;286      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000032  89a8              LDRH     r0,[r5,#0xc]
000034  4308              ORRS     r0,r0,r1
;;;287    
;;;288      /* Write to USART CR3 */
;;;289      USARTx->CR3 = (uint16_t)tmpreg;
000036  b280              UXTH     r0,r0
000038  6160              STR      r0,[r4,#0x14]
;;;290    
;;;291    /*---------------------------- USART BRR Configuration -----------------------*/
;;;292      /* Configure the USART Baud Rate */
;;;293      RCC_GetClocksFreq(&RCC_ClocksStatus);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       RCC_GetClocksFreq
;;;294    
;;;295      if ((USARTx == USART1) || (USARTx == USART6))
000040  481a              LDR      r0,|L12.172|
000042  4284              CMP      r4,r0
000044  d002              BEQ      |L12.76|
000046  481a              LDR      r0,|L12.176|
000048  4284              CMP      r4,r0
00004a  d101              BNE      |L12.80|
                  |L12.76|
;;;296      {
;;;297        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
00004c  9803              LDR      r0,[sp,#0xc]
00004e  e000              B        |L12.82|
                  |L12.80|
;;;298      }
;;;299      else
;;;300      {
;;;301        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000050  9802              LDR      r0,[sp,#8]
                  |L12.82|
;;;302      }
;;;303      
;;;304      /* Determine the integer part */
;;;305      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000052  68e1              LDR      r1,[r4,#0xc]
000054  0409              LSLS     r1,r1,#16
;;;306      {
;;;307        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;308        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;309      }
;;;310      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;311      {
;;;312        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;313        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000056  eb0001c0          ADD      r1,r0,r0,LSL #3
00005a  eb011000          ADD      r0,r1,r0,LSL #4
00005e  6829              LDR      r1,[r5,#0]            ;305
000060  d501              BPL      |L12.102|
000062  0049              LSLS     r1,r1,#1              ;308
000064  e000              B        |L12.104|
                  |L12.102|
000066  0089              LSLS     r1,r1,#2
                  |L12.104|
000068  fbb0f0f1          UDIV     r0,r0,r1
;;;314      }
;;;315      tmpreg = (integerdivider / 100) << 4;
00006c  2264              MOVS     r2,#0x64
00006e  fbb0f1f2          UDIV     r1,r0,r2
000072  0109              LSLS     r1,r1,#4
;;;316    
;;;317      /* Determine the fractional part */
;;;318      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000074  090b              LSRS     r3,r1,#4
000076  f06f0518          MVN      r5,#0x18
00007a  436b              MULS     r3,r5,r3
00007c  eb000083          ADD      r0,r0,r3,LSL #2
;;;319    
;;;320      /* Implement the fractional part in the register */
;;;321      if ((USARTx->CR1 & USART_CR1_OVER8) != 0)
000080  68e3              LDR      r3,[r4,#0xc]
000082  041d              LSLS     r5,r3,#16
;;;322      {
;;;323        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000084  f04f0332          MOV      r3,#0x32
000088  d506              BPL      |L12.152|
00008a  eb0300c0          ADD      r0,r3,r0,LSL #3
00008e  fbb0f0f2          UDIV     r0,r0,r2
000092  f0000007          AND      r0,r0,#7
000096  e005              B        |L12.164|
                  |L12.152|
;;;324      }
;;;325      else /* if ((USARTx->CR1 & USART_CR1_OVER8) == 0) */
;;;326      {
;;;327        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
000098  eb031000          ADD      r0,r3,r0,LSL #4
00009c  fbb0f0f2          UDIV     r0,r0,r2
0000a0  f000000f          AND      r0,r0,#0xf
                  |L12.164|
0000a4  4308              ORRS     r0,r0,r1
;;;328      }
;;;329      
;;;330      /* Write to USART BRR register */
;;;331      USARTx->BRR = (uint16_t)tmpreg;
0000a6  b280              UXTH     r0,r0
0000a8  60a0              STR      r0,[r4,#8]
;;;332    }
0000aa  bd7f              POP      {r0-r6,pc}
;;;333    
                          ENDP

                  |L12.172|
                          DCD      0x40011000
                  |L12.176|
                          DCD      0x40011400

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;1033     */
;;;1034   void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1035   {
;;;1036     /* Check the parameters */
;;;1037     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1038     //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1039       
;;;1040     if (NewState != DISABLE)
;;;1041     {
;;;1042       /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;1043       USARTx->CR3 |= USART_CR3_IREN;
;;;1044     }
;;;1045     else
;;;1046     {
;;;1047       /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;1048       USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IREN);
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L13.12|
000006  f0410102          ORR      r1,r1,#2              ;1043
00000a  e002              B        |L13.18|
                  |L13.12|
00000c  f64f72fd          MOV      r2,#0xfffd
000010  4011              ANDS     r1,r1,r2
                  |L13.18|
000012  6141              STR      r1,[r0,#0x14]         ;1043
;;;1049     }
;;;1050   }
000014  4770              BX       lr
;;;1051   
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;1015     */
;;;1016   void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  6942              LDR      r2,[r0,#0x14]
;;;1017   {
;;;1018     /* Check the parameters */
;;;1019     //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1020     //assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;1021       
;;;1022     USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_IRLP);
000002  f64f73fb          MOV      r3,#0xfffb
000006  401a              ANDS     r2,r2,r3
000008  6142              STR      r2,[r0,#0x14]
;;;1023     USARTx->CR3 |= USART_IrDAMode;
00000a  6942              LDR      r2,[r0,#0x14]
00000c  430a              ORRS     r2,r2,r1
00000e  6142              STR      r2,[r0,#0x14]
;;;1024   }
000010  4770              BX       lr
;;;1025   
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;720      */
;;;721    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  6902              LDR      r2,[r0,#0x10]
;;;722    {
;;;723      /* Check the parameters */
;;;724      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;725      //assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;726      
;;;727      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LBDL);
000002  f64f73df          MOV      r3,#0xffdf
000006  401a              ANDS     r2,r2,r3
000008  6102              STR      r2,[r0,#0x10]
;;;728      USARTx->CR2 |= USART_LINBreakDetectLength;  
00000a  6902              LDR      r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  6102              STR      r2,[r0,#0x10]
;;;729    }
000010  4770              BX       lr
;;;730    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;738      */
;;;739    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;740    {
;;;741      /* Check the parameters */
;;;742      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;743      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;744      
;;;745      if (NewState != DISABLE)
;;;746      {
;;;747        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;748        USARTx->CR2 |= USART_CR2_LINEN;
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;753        USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_LINEN);
000002  6901              LDR      r1,[r0,#0x10]
000004  d002              BEQ      |L16.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;748
00000a  e002              B        |L16.18|
                  |L16.12|
00000c  f64b72ff          MOV      r2,#0xbfff
000010  4011              ANDS     r1,r1,r2
                  |L16.18|
000012  6101              STR      r1,[r0,#0x10]         ;748
;;;754      }
;;;755    }
000014  4770              BX       lr
;;;756    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;480      */
;;;481    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;482    {
;;;483    //  /* Check the parameters */
;;;484    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;485    //  //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;486      
;;;487      if (NewState != DISABLE)
;;;488      {
;;;489        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;490        USARTx->CR3 |= USART_CR3_ONEBIT;
;;;491      }
;;;492      else
;;;493      {
;;;494        /* Disable the one bit method by clearing the ONEBITE bit in the CR3 register */
;;;495        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_ONEBIT);
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L17.12|
000006  f4416100          ORR      r1,r1,#0x800          ;490
00000a  e002              B        |L17.18|
                  |L17.12|
00000c  f24f72ff          MOV      r2,#0xf7ff
000010  4011              ANDS     r1,r1,r2
                  |L17.18|
000012  6141              STR      r1,[r0,#0x14]         ;490
;;;496      }
;;;497    }
000014  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;454      */
;;;455    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;456    {
;;;457    //  /* Check the parameters */
;;;458    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;459    //  //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;460      
;;;461      if (NewState != DISABLE)
;;;462      {
;;;463        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;464        USARTx->CR1 |= USART_CR1_OVER8;
;;;465      }
;;;466      else
;;;467      {
;;;468        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;469        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_OVER8);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L18.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;464
00000a  e001              B        |L18.16|
                  |L18.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L18.16|
000010  60c1              STR      r1,[r0,#0xc]          ;464
;;;470      }
;;;471    }  
000012  4770              BX       lr
;;;472    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;553      */
;;;554    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  6840              LDR      r0,[r0,#4]
;;;555    {
;;;556    //  /* Check the parameters */
;;;557    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;558      
;;;559      /* Receive Data */
;;;560      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;561    }
000006  4770              BX       lr
;;;562    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;624      */
;;;625    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;626    {
;;;627      /* Check the parameters */
;;;628      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;629      //assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;630      
;;;631      if (NewState != DISABLE)
;;;632      {
;;;633        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;634        USARTx->CR1 |= USART_CR1_RWU;
;;;635      }
;;;636      else
;;;637      {
;;;638        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;639        USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_RWU);
000002  68c1              LDR      r1,[r0,#0xc]
000004  d002              BEQ      |L20.12|
000006  f0410102          ORR      r1,r1,#2              ;634
00000a  e002              B        |L20.18|
                  |L20.12|
00000c  f64f72fd          MOV      r2,#0xfffd
000010  4011              ANDS     r1,r1,r2
                  |L20.18|
000012  60c1              STR      r1,[r0,#0xc]          ;634
;;;640      }
;;;641    }
000014  4770              BX       lr
;;;642    /**
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;762      */
;;;763    void USART_SendBreak(USART_TypeDef* USARTx)
000000  68c1              LDR      r1,[r0,#0xc]
;;;764    {
;;;765      /* Check the parameters */
;;;766      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;767      
;;;768      /* Send break characters */
;;;769      USARTx->CR1 |= USART_CR1_SBK;
000002  f0410101          ORR      r1,r1,#1
000006  60c1              STR      r1,[r0,#0xc]
;;;770    }
000008  4770              BX       lr
;;;771    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;537      */
;;;538    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;539    {
;;;540    //  /* Check the parameters */
;;;541    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;542    //  //assert_param(IS_USART_DATA(Data)); 
;;;543        
;;;544      /* Transmit Data */
;;;545      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  6041              STR      r1,[r0,#4]
;;;546    }
000006  4770              BX       lr
;;;547    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;604      */
;;;605    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  6902              LDR      r2,[r0,#0x10]
;;;606    {
;;;607      /* Check the parameters */
;;;608      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;609      //assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;610        
;;;611      /* Clear the USART address */
;;;612      USARTx->CR2 &= (uint16_t)~((uint16_t)USART_CR2_ADD);
000002  f64f73f0          MOV      r3,#0xfff0
000006  401a              ANDS     r2,r2,r3
000008  6102              STR      r2,[r0,#0x10]
;;;613      /* Set the USART address node */
;;;614      USARTx->CR2 |= USART_Address;
00000a  6902              LDR      r2,[r0,#0x10]
00000c  430a              ORRS     r2,r2,r1
00000e  6102              STR      r2,[r0,#0x10]
;;;615    }
000010  4770              BX       lr
;;;616    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;900      */
;;;901    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  6982              LDR      r2,[r0,#0x18]
;;;902    {    
;;;903      /* Check the parameters */
;;;904      //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;905      
;;;906      /* Clear the USART Guard time */
;;;907      USARTx->GTPR &= USART_GTPR_PSC;
000002  b2d2              UXTB     r2,r2
000004  6182              STR      r2,[r0,#0x18]
;;;908      /* Set the USART guard time */
;;;909      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  6982              LDR      r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  6181              STR      r1,[r0,#0x18]
;;;910    }
00000e  4770              BX       lr
;;;911    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;433      */
;;;434    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  4770              BX       lr
;;;435    { 
;;;436    //  /* Check the parameters */
;;;437    //  //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;438      
;;;439    //  /* Clear the USART prescaler */
;;;440    //  USARTx->GTPR &= USART_GTPR_GT;
;;;441    //  /* Set the USART prescaler */
;;;442    //  USARTx->GTPR |= USART_Prescaler;
;;;443    }
;;;444    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;919      */
;;;920    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;921    {
;;;922      /* Check the parameters */
;;;923      //assert_param(IS_USART_1236_PERIPH(USARTx));
;;;924      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;925      if (NewState != DISABLE)
;;;926      {
;;;927        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;928        USARTx->CR3 |= USART_CR3_SCEN;
;;;929      }
;;;930      else
;;;931      {
;;;932        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;933        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_SCEN);
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L26.12|
000006  f0410120          ORR      r1,r1,#0x20           ;928
00000a  e002              B        |L26.18|
                  |L26.12|
00000c  f64f72df          MOV      r2,#0xffdf
000010  4011              ANDS     r1,r1,r2
                  |L26.18|
000012  6141              STR      r1,[r0,#0x14]         ;928
;;;934      }
;;;935    }
000014  4770              BX       lr
;;;936    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;944      */
;;;945    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;946    {
;;;947      /* Check the parameters */
;;;948      //assert_param(IS_USART_1236_PERIPH(USARTx)); 
;;;949      //assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;950      if (NewState != DISABLE)
;;;951      {
;;;952        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;953        USARTx->CR3 |= USART_CR3_NACK;
;;;954      }
;;;955      else
;;;956      {
;;;957        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;958        USARTx->CR3 &= (uint16_t)~((uint16_t)USART_CR3_NACK);
000002  6941              LDR      r1,[r0,#0x14]
000004  d002              BEQ      |L27.12|
000006  f0410110          ORR      r1,r1,#0x10           ;953
00000a  e002              B        |L27.18|
                  |L27.12|
00000c  f64f72ef          MOV      r2,#0xffef
000010  4011              ANDS     r1,r1,r2
                  |L27.18|
000012  6141              STR      r1,[r0,#0x14]         ;953
;;;959      }
;;;960    }
000014  4770              BX       lr
;;;961    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;339      */
;;;340    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;341    {
;;;342      /* USART_InitStruct members default value */
;;;343      USART_InitStruct->USART_BaudRate = 9600;
;;;344      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;345      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;346      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;347      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;348      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;349    }
000014  4770              BX       lr
;;;350    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;651      */
;;;652    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  68c2              LDR      r2,[r0,#0xc]
;;;653    {
;;;654      /* Check the parameters */
;;;655      //assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;656      //assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;657      
;;;658      USARTx->CR1 &= (uint16_t)~((uint16_t)USART_CR1_WAKE);
000002  f24f73ff          MOV      r3,#0xf7ff
000006  401a              ANDS     r2,r2,r3
000008  60c2              STR      r2,[r0,#0xc]
;;;659      USARTx->CR1 |= USART_WakeUp;
00000a  68c2              LDR      r2,[r0,#0xc]
00000c  430a              ORRS     r2,r2,r1
00000e  60c2              STR      r2,[r0,#0xc]
;;;660    }
000010  4770              BX       lr
;;;661    
                          ENDP


;*** Start embedded assembler ***

#line 1 "drivers\\stm32f4xx_usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___17_stm32f4xx_usart_c_9565154b____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____REVSH|
#line 223
|__asm___17_stm32f4xx_usart_c_9565154b____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_stm32f4xx_usart_c_9565154b____RRX|
#line 410
|__asm___17_stm32f4xx_usart_c_9565154b____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
