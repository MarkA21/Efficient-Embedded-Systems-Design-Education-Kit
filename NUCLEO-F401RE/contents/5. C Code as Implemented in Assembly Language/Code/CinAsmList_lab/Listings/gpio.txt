; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\gpio.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\gpio.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\gpio.crf drivers\gpio.c]
                          THUMB

                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI0_IRQHandler PROC
;;;265    //Note: only four interrupt lines are implemented i.e. only use pin 0-4
;;;266    void EXTI0_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;267    	
;;;268    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L1.60|
000004  490e              LDR      r1,|L1.64|
;;;269    	IRQ_status = EXTI->PR>>IRQ_pin_index & 1;		
000006  4d0f              LDR      r5,|L1.68|
000008  6860              LDR      r0,[r4,#4]            ;268  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;268
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;270    	NVIC_ClearPendingIRQ(EXTI0_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  2006              MOVS     r0,#6
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;271    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;272    	
;;;273    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L1.58|
;;;274    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L1.58|
;;;275    	}
;;;276    }
00003a  bd70              POP      {r4-r6,pc}
;;;277    
                          ENDP

                  |L1.60|
                          DCD      ||.data||
                  |L1.64|
                          DCD      0x40020000
                  |L1.68|
                          DCD      0x40013c14

                          AREA ||i.EXTI15_10_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI15_10_IRQHandler PROC
;;;341    
;;;342    void EXTI15_10_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;343    	
;;;344    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L2.60|
000004  490e              LDR      r1,|L2.64|
;;;345    	IRQ_status = (EXTI->PR>>IRQ_pin_index) & 1;
000006  4d0f              LDR      r5,|L2.68|
000008  6860              LDR      r0,[r4,#4]            ;344  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;344
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;346    	NVIC_ClearPendingIRQ(EXTI15_10_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  2028              MOVS     r0,#0x28
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;347    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;348    	
;;;349    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L2.58|
;;;350    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L2.58|
;;;351    	}
;;;352    	
;;;353    }
00003a  bd70              POP      {r4-r6,pc}
;;;354    
                          ENDP

                  |L2.60|
                          DCD      ||.data||
                  |L2.64|
                          DCD      0x40020000
                  |L2.68|
                          DCD      0x40013c14

                          AREA ||i.EXTI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI1_IRQHandler PROC
;;;277    
;;;278    void EXTI1_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;279    	
;;;280    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L3.60|
000004  490e              LDR      r1,|L3.64|
;;;281    	IRQ_status = EXTI->PR>>IRQ_pin_index & 1;	
000006  4d0f              LDR      r5,|L3.68|
000008  6860              LDR      r0,[r4,#4]            ;280  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;280
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;282    	NVIC_ClearPendingIRQ(EXTI1_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  2007              MOVS     r0,#7
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;283    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;284    	
;;;285    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L3.58|
;;;286    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L3.58|
;;;287    	}
;;;288    	
;;;289    }
00003a  bd70              POP      {r4-r6,pc}
;;;290    
                          ENDP

                  |L3.60|
                          DCD      ||.data||
                  |L3.64|
                          DCD      0x40020000
                  |L3.68|
                          DCD      0x40013c14

                          AREA ||i.EXTI2_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI2_IRQHandler PROC
;;;290    
;;;291    void EXTI2_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;292    	
;;;293    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L4.60|
000004  490e              LDR      r1,|L4.64|
;;;294    	IRQ_status = EXTI->PR>>IRQ_pin_index & 1;	
000006  4d0f              LDR      r5,|L4.68|
000008  6860              LDR      r0,[r4,#4]            ;293  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;293
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;295    	NVIC_ClearPendingIRQ(EXTI2_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  2008              MOVS     r0,#8
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;296    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;297    	
;;;298    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L4.58|
;;;299    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L4.58|
;;;300    	}
;;;301    	
;;;302    }
00003a  bd70              POP      {r4-r6,pc}
;;;303    
                          ENDP

                  |L4.60|
                          DCD      ||.data||
                  |L4.64|
                          DCD      0x40020000
                  |L4.68|
                          DCD      0x40013c14

                          AREA ||i.EXTI3_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI3_IRQHandler PROC
;;;303    
;;;304    void EXTI3_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;305    	
;;;306    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L5.60|
000004  490e              LDR      r1,|L5.64|
;;;307    	IRQ_status = EXTI->PR>>IRQ_pin_index & 1;	
000006  4d0f              LDR      r5,|L5.68|
000008  6860              LDR      r0,[r4,#4]            ;306  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;306
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;308    	NVIC_ClearPendingIRQ(EXTI3_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  2009              MOVS     r0,#9
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;309    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;310    	
;;;311    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L5.58|
;;;312    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L5.58|
;;;313    	}
;;;314    	
;;;315    }
00003a  bd70              POP      {r4-r6,pc}
;;;316    
                          ENDP

                  |L5.60|
                          DCD      ||.data||
                  |L5.64|
                          DCD      0x40020000
                  |L5.68|
                          DCD      0x40013c14

                          AREA ||i.EXTI4_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI4_IRQHandler PROC
;;;316    
;;;317    void EXTI4_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;318    	
;;;319    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L6.60|
000004  490e              LDR      r1,|L6.64|
;;;320    	IRQ_status = EXTI->PR>>IRQ_pin_index & 1;
000006  4d0f              LDR      r5,|L6.68|
000008  6860              LDR      r0,[r4,#4]            ;319  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;319
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;321    	NVIC_ClearPendingIRQ(EXTI4_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  200a              MOVS     r0,#0xa
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;322    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;323    	
;;;324    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L6.58|
;;;325    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L6.58|
;;;326    	}
;;;327    }
00003a  bd70              POP      {r4-r6,pc}
;;;328    
                          ENDP

                  |L6.60|
                          DCD      ||.data||
                  |L6.64|
                          DCD      0x40020000
                  |L6.68|
                          DCD      0x40013c14

                          AREA ||i.EXTI9_5_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI9_5_IRQHandler PROC
;;;328    
;;;329    void EXTI9_5_IRQHandler(void){
000000  b570              PUSH     {r4-r6,lr}
;;;330    	
;;;331    	GPIO_TypeDef* p = ((GPIO_TypeDef*)(AHB1PERIPH_BASE + 0x0400 * IRQ_port_num));
000002  4c0e              LDR      r4,|L7.60|
000004  490e              LDR      r1,|L7.64|
;;;332    	IRQ_status = (EXTI->PR>>IRQ_pin_index) & 1;
000006  4d0f              LDR      r5,|L7.68|
000008  6860              LDR      r0,[r4,#4]            ;331  ; IRQ_port_num
00000a  eb012680          ADD      r6,r1,r0,LSL #10      ;331
00000e  6828              LDR      r0,[r5,#0]
000010  7a21              LDRB     r1,[r4,#8]  ; IRQ_pin_index
000012  40c8              LSRS     r0,r0,r1
000014  f0000001          AND      r0,r0,#1
;;;333    	NVIC_ClearPendingIRQ(EXTI9_5_IRQn);
000018  6020              STR      r0,[r4,#0]  ; IRQ_status
00001a  2017              MOVS     r0,#0x17
00001c  f7fffffe          BL       __NVIC_ClearPendingIRQ
;;;334    	EXTI->PR|=(1<<IRQ_pin_index);
000020  682a              LDR      r2,[r5,#0]
000022  68a0              LDR      r0,[r4,#8]  ; IRQ_pin_index
000024  2101              MOVS     r1,#1
000026  4081              LSLS     r1,r1,r0
000028  430a              ORRS     r2,r2,r1
00002a  602a              STR      r2,[r5,#0]
;;;335    	
;;;336    	if(p->IDR&(1<<IRQ_pin_index)){
00002c  6932              LDR      r2,[r6,#0x10]
00002e  420a              TST      r2,r1
000030  d003              BEQ      |L7.58|
;;;337    		GPIO_callback(IRQ_pin_index);
000032  69a1              LDR      r1,[r4,#0x18]  ; GPIO_callback
000034  e8bd4070          POP      {r4-r6,lr}
000038  4708              BX       r1
                  |L7.58|
;;;338    	}
;;;339    }
00003a  bd70              POP      {r4-r6,pc}
;;;340    
                          ENDP

                  |L7.60|
                          DCD      ||.data||
                  |L7.64|
                          DCD      0x40020000
                  |L7.68|
                          DCD      0x40013c14

                          AREA ||i.NVIC_EncodePriority||, CODE, READONLY, ALIGN=1

                  NVIC_EncodePriority PROC
;;;1860    */
;;;1861   __STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
000000  b530              PUSH     {r4,r5,lr}
;;;1862   {
;;;1863     uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
000002  f0000307          AND      r3,r0,#7
;;;1864     uint32_t PreemptPriorityBits;
;;;1865     uint32_t SubPriorityBits;
;;;1866   
;;;1867     PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
000006  f1c30407          RSB      r4,r3,#7
00000a  2c04              CMP      r4,#4
00000c  d900              BLS      |L8.16|
00000e  2404              MOVS     r4,#4
                  |L8.16|
;;;1868     SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
000010  1d18              ADDS     r0,r3,#4
000012  2807              CMP      r0,#7
000014  d201              BCS      |L8.26|
000016  2300              MOVS     r3,#0
000018  e000              B        |L8.28|
                  |L8.26|
00001a  1edb              SUBS     r3,r3,#3
                  |L8.28|
;;;1869   
;;;1870     return (
00001c  2501              MOVS     r5,#1
00001e  fa05f004          LSL      r0,r5,r4
000022  1e40              SUBS     r0,r0,#1
000024  4008              ANDS     r0,r0,r1
000026  4098              LSLS     r0,r0,r3
000028  409d              LSLS     r5,r5,r3
00002a  1e6d              SUBS     r5,r5,#1
00002c  4015              ANDS     r5,r5,r2
00002e  4328              ORRS     r0,r0,r5
;;;1871              ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
;;;1872              ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
;;;1873            );
;;;1874   }
000030  bd30              POP      {r4,r5,pc}
;;;1875   
                          ENDP


                          AREA ||i.__NVIC_ClearPendingIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_ClearPendingIRQ PROC
;;;1774    */
;;;1775   __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1776   {
000002  db09              BLT      |L9.24|
;;;1777     if ((int32_t)(IRQn) >= 0)
;;;1778     {
;;;1779       NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01280          STR      r1,[r0,#0x280]
                  |L9.24|
;;;1780     }
;;;1781   }
000018  4770              BX       lr
;;;1782   
                          ENDP


                          AREA ||i.__NVIC_EnableIRQ||, CODE, READONLY, ALIGN=1

                  __NVIC_EnableIRQ PROC
;;;1683    */
;;;1684   __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
000000  2800              CMP      r0,#0
;;;1685   {
000002  db09              BLT      |L10.24|
;;;1686     if ((int32_t)(IRQn) >= 0)
;;;1687     {
;;;1688       __COMPILER_BARRIER();
;;;1689       NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
000004  f000021f          AND      r2,r0,#0x1f
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  0940              LSRS     r0,r0,#5
00000e  0080              LSLS     r0,r0,#2
000010  f10020e0          ADD      r0,r0,#0xe000e000
000014  f8c01100          STR      r1,[r0,#0x100]
                  |L10.24|
;;;1690       __COMPILER_BARRIER();
;;;1691     }
;;;1692   }
000018  4770              BX       lr
;;;1693   
                          ENDP


                          AREA ||i.__NVIC_GetPriorityGrouping||, CODE, READONLY, ALIGN=2

                  __NVIC_GetPriorityGrouping PROC
;;;1671    */
;;;1672   __STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
000000  4802              LDR      r0,|L11.12|
;;;1673   {
;;;1674     return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
000002  6800              LDR      r0,[r0,#0]
000004  f3c02002          UBFX     r0,r0,#8,#3
;;;1675   }
000008  4770              BX       lr
;;;1676   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0xe000ed0c

                          AREA ||i.__NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  __NVIC_SetPriority PROC
;;;1813    */
;;;1814   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1815   {
;;;1816     if ((int32_t)(IRQn) >= 0)
;;;1817     {
;;;1818       NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1816
000006  db04              BLT      |L12.18|
000008  f10020e0          ADD      r0,r0,#0xe000e000     ;1815
00000c  f8801400          STRB     r1,[r0,#0x400]
;;;1819     }
;;;1820     else
;;;1821     {
;;;1822       SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1823     }
;;;1824   }
000010  4770              BX       lr
                  |L12.18|
000012  f000000f          AND      r0,r0,#0xf            ;1822
000016  f10020e0          ADD      r0,r0,#0xe000e000     ;1822
00001a  f8801d14          STRB     r1,[r0,#0xd14]        ;1822
00001e  4770              BX       lr
;;;1825   
                          ENDP


                          AREA ||i.gpio_get||, CODE, READONLY, ALIGN=2

                  gpio_get PROC
;;;30     
;;;31     int gpio_get(Pin pin) {
000000  4a04              LDR      r2,|L13.20|
;;;32     	// Gets the current value of the specified pin.
;;;33     	
;;;34     	GPIO_TypeDef* p = GET_PORT(pin);
000002  1401              ASRS     r1,r0,#16
000004  eb022281          ADD      r2,r2,r1,LSL #10
;;;35     	uint32_t pin_index = GET_PIN_INDEX(pin);
000008  4601              MOV      r1,r0
;;;36     	
;;;37     	return READ_BIT(p->IDR,(1<<pin_index));
00000a  6910              LDR      r0,[r2,#0x10]
00000c  2201              MOVS     r2,#1
00000e  408a              LSLS     r2,r2,r1
000010  4010              ANDS     r0,r0,r2
;;;38     	
;;;39     }
000012  4770              BX       lr
;;;40     
                          ENDP

                  |L13.20|
                          DCD      0x40020000

                          AREA ||i.gpio_get_range||, CODE, READONLY, ALIGN=2

                  gpio_get_range PROC
;;;58     
;;;59     unsigned int gpio_get_range(Pin pin_base, int count) {
000000  4b06              LDR      r3,|L14.28|
;;;60     	// Gets a range of pins.
;;;61     	
;;;62     	// This can be used to read an entire port, or just
;;;63     	// a subset of the (consecutive) pins on a port.
;;;64     	
;;;65     	// The LSB of the return value should be the state of
;;;66     	// pin_base. (LSB + 1) of the return value should be
;;;67     	// the state of (pin_base + 1) etc.
;;;68     	// e.g. if the state of pin_base is P1_0 (port 1, pin 0)
;;;69     	// and count is 4 this, function should return:
;;;70     	// (P1_3 << 3) | (P1_2 << 2) | (P1_1 << 1) | P1_0
;;;71     	
;;;72     	// The mask for the value parameter should be:
;;;73     	// ((1 << count) - 1).
;;;74     	GPIO_TypeDef* p = GET_PORT(pin_base);
000002  1402              ASRS     r2,r0,#16
000004  eb032382          ADD      r3,r3,r2,LSL #10
;;;75     	uint32_t pin_index = GET_PIN_INDEX(pin_base);
000008  4602              MOV      r2,r0
;;;76     	
;;;77     	return READ_BIT(p->IDR,(((1 << count) - 1)<<pin_index))>>pin_index;
00000a  6918              LDR      r0,[r3,#0x10]
00000c  2301              MOVS     r3,#1
00000e  408b              LSLS     r3,r3,r1
000010  1e5b              SUBS     r3,r3,#1
000012  4093              LSLS     r3,r3,r2
000014  4018              ANDS     r0,r0,r3
000016  40d0              LSRS     r0,r0,r2
;;;78     }
000018  4770              BX       lr
;;;79     
                          ENDP

00001a  0000              DCW      0x0000
                  |L14.28|
                          DCD      0x40020000

                          AREA ||i.gpio_set||, CODE, READONLY, ALIGN=2

                  gpio_set PROC
;;;21     
;;;22     void gpio_set(Pin pin, int value) {
000000  4b06              LDR      r3,|L15.28|
;;;23     	// Sets the selected pin to the specified value.
;;;24     	
;;;25     	GPIO_TypeDef* p = GET_PORT(pin);
000002  1402              ASRS     r2,r0,#16
000004  b510              PUSH     {r4,lr}               ;22
000006  eb032282          ADD      r2,r3,r2,LSL #10
;;;26     	uint32_t pin_index = GET_PIN_INDEX(pin);
;;;27     	
;;;28     	MODIFY_REG(p->ODR,1UL<<pin_index,value<<pin_index);
00000a  6953              LDR      r3,[r2,#0x14]
00000c  2401              MOVS     r4,#1
00000e  4084              LSLS     r4,r4,r0
000010  43a3              BICS     r3,r3,r4
000012  4081              LSLS     r1,r1,r0
000014  430b              ORRS     r3,r3,r1
000016  6153              STR      r3,[r2,#0x14]
;;;29     }
000018  bd10              POP      {r4,pc}
;;;30     
                          ENDP

00001a  0000              DCW      0x0000
                  |L15.28|
                          DCD      0x40020000

                          AREA ||i.gpio_set_callback||, CODE, READONLY, ALIGN=2

                  gpio_set_callback PROC
;;;158    
;;;159    void gpio_set_callback(Pin pin, void (*callback)(int status)) {
000000  b570              PUSH     {r4-r6,lr}
000002  460a              MOV      r2,r1
;;;160    	// Set up and enable the interrupt on the passed pin's
;;;161    	// port.
;;;162    	
;;;163    	// The callback function should be stored in an internal
;;;164    	// static function pointer.
;;;165    	
;;;166    	// When the port ISR is fired, the callback function
;;;167    	// should be executed. The status parameter should equal
;;;168    	// a mask of which pin triggered the interrupt, for
;;;169    	// example if a callback is set on pin P1_2 (port 1, pin
;;;170    	// 2) and the interrupt is triggered on port 1, the
;;;171    	// function callback should be called with argument
;;;172    	// status equalling 0b00000100.
;;;173    	// This allows the user to determine the interrupt source
;;;174    	// with (status & GET_PIN_INDEX(P1_2)).
;;;175    	__enable_irq();
000004  b662              CPSIE    i
;;;176      IRQ_status = 0;
000006  2100              MOVS     r1,#0
000008  4c54              LDR      r4,|L16.348|
;;;177    	IRQ_port_num = GET_PORT_INDEX(pin);
;;;178    	IRQ_pin_index = GET_PIN_INDEX(pin);
00000a  b2c5              UXTB     r5,r0
00000c  6021              STR      r1,[r4,#0]            ;177  ; IRQ_status
00000e  1401              ASRS     r1,r0,#16             ;177
;;;179    	EXTI_port_set = IRQ_port_num<<(IRQ_pin_index % 4) * 4;
000010  e9c41501          STRD     r1,r5,[r4,#4]
000014  07a8              LSLS     r0,r5,#30
000016  0f00              LSRS     r0,r0,#28
000018  4081              LSLS     r1,r1,r0
;;;180    	
;;;181    	GPIO_callback = callback;
;;;182    	//Connect the pin to external interrupt line
;;;183    	switch(IRQ_pin_index){
;;;184    		case 0:
;;;185    			SYSCFG->EXTICR[0]|= EXTI_port_set;
00001a  4851              LDR      r0,|L16.352|
;;;186    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;187    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;188    			NVIC_SetPriority(EXTI0_IRQn, priority);
;;;189    		  NVIC_EnableIRQ(EXTI0_IRQn);		
;;;190    		break;
;;;191    
;;;192    		case 1:
;;;193    			SYSCFG->EXTICR[0]|= EXTI_port_set;
;;;194    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;195    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;196    			NVIC_SetPriority(EXTI1_IRQn, priority);
;;;197    		  NVIC_EnableIRQ(EXTI1_IRQn);
;;;198    		break;
;;;199    		
;;;200        case 2:
;;;201    			SYSCFG->EXTICR[0]|= EXTI_port_set;
;;;202    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;203    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;204    			NVIC_SetPriority(EXTI2_IRQn, priority);
;;;205    		  NVIC_EnableIRQ(EXTI2_IRQn);
;;;206    		break;
;;;207    		
;;;208    		case 3:
;;;209    			SYSCFG->EXTICR[0]|= EXTI_port_set;
;;;210    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;211    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;212    			NVIC_SetPriority(EXTI3_IRQn, priority);
;;;213    		  NVIC_EnableIRQ(EXTI3_IRQn);
;;;214    		break;
;;;215    		
;;;216    		case 4:
;;;217    			SYSCFG->EXTICR[1]|= EXTI_port_set;
00001c  61a2              STR      r2,[r4,#0x18]  ; GPIO_callback
00001e  1d02              ADDS     r2,r0,#4
;;;218    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;219    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;220    			NVIC_SetPriority(EXTI4_IRQn, priority);
;;;221    		  NVIC_EnableIRQ(EXTI4_IRQn);
;;;222    		break;
;;;223    		
;;;224    		case 5:
;;;225        case 6:
;;;226    		case 7:
;;;227    			SYSCFG->EXTICR[1]|= EXTI_port_set;
;;;228    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;229    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;230    			NVIC_SetPriority(EXTI9_5_IRQn, priority);
;;;231    		  NVIC_EnableIRQ(EXTI9_5_IRQn);
;;;232    		break;
;;;233    		
;;;234    		case 8:
;;;235    		case 9:
;;;236    			SYSCFG->EXTICR[2]|= EXTI_port_set;
000020  1d13              ADDS     r3,r2,#4
000022  60e1              STR      r1,[r4,#0xc]          ;217  ; EXTI_port_set
000024  2d10              CMP      r5,#0x10              ;183
000026  d27c              BCS      |L16.290|
000028  e8dff005          TBB      [pc,r5]               ;183
00002c  08192a3b          DCB      0x08,0x19,0x2a,0x3b
000030  4c5d5d5d          DCB      0x4c,0x5d,0x5d,0x5d
000034  6a6a7c7c          DCB      0x6a,0x6a,0x7c,0x7c
000038  80808080          DCB      0x80,0x80,0x80,0x80
00003c  6802              LDR      r2,[r0,#0]            ;185
00003e  430a              ORRS     r2,r2,r1              ;185
000040  6002              STR      r2,[r0,#0]            ;185
000042  f7fffffe          BL       __NVIC_GetPriorityGrouping
000046  2201              MOVS     r2,#1                 ;187
000048  4611              MOV      r1,r2                 ;187
00004a  6120              STR      r0,[r4,#0x10]         ;187  ; prioritygroup
00004c  f7fffffe          BL       NVIC_EncodePriority
000050  4601              MOV      r1,r0                 ;187
000052  6160              STR      r0,[r4,#0x14]         ;188  ; priority
000054  2006              MOVS     r0,#6                 ;188
000056  f7fffffe          BL       __NVIC_SetPriority
00005a  2006              MOVS     r0,#6                 ;189
00005c  e078              B        |L16.336|
00005e  6802              LDR      r2,[r0,#0]            ;193
000060  430a              ORRS     r2,r2,r1              ;193
000062  6002              STR      r2,[r0,#0]            ;193
000064  f7fffffe          BL       __NVIC_GetPriorityGrouping
000068  2201              MOVS     r2,#1                 ;195
00006a  4611              MOV      r1,r2                 ;195
00006c  6120              STR      r0,[r4,#0x10]         ;195  ; prioritygroup
00006e  f7fffffe          BL       NVIC_EncodePriority
000072  4601              MOV      r1,r0                 ;195
000074  6160              STR      r0,[r4,#0x14]         ;196  ; priority
000076  2007              MOVS     r0,#7                 ;196
000078  f7fffffe          BL       __NVIC_SetPriority
00007c  2007              MOVS     r0,#7                 ;197
00007e  e067              B        |L16.336|
000080  6802              LDR      r2,[r0,#0]            ;201
000082  430a              ORRS     r2,r2,r1              ;201
000084  6002              STR      r2,[r0,#0]            ;201
000086  f7fffffe          BL       __NVIC_GetPriorityGrouping
00008a  2201              MOVS     r2,#1                 ;203
00008c  4611              MOV      r1,r2                 ;203
00008e  6120              STR      r0,[r4,#0x10]         ;203  ; prioritygroup
000090  f7fffffe          BL       NVIC_EncodePriority
000094  4601              MOV      r1,r0                 ;203
000096  6160              STR      r0,[r4,#0x14]         ;204  ; priority
000098  2008              MOVS     r0,#8                 ;204
00009a  f7fffffe          BL       __NVIC_SetPriority
00009e  2008              MOVS     r0,#8                 ;205
0000a0  e056              B        |L16.336|
0000a2  6802              LDR      r2,[r0,#0]            ;209
0000a4  430a              ORRS     r2,r2,r1              ;209
0000a6  6002              STR      r2,[r0,#0]            ;209
0000a8  f7fffffe          BL       __NVIC_GetPriorityGrouping
0000ac  2201              MOVS     r2,#1                 ;211
0000ae  4611              MOV      r1,r2                 ;211
0000b0  6120              STR      r0,[r4,#0x10]         ;211  ; prioritygroup
0000b2  f7fffffe          BL       NVIC_EncodePriority
0000b6  4601              MOV      r1,r0                 ;211
0000b8  6160              STR      r0,[r4,#0x14]         ;212  ; priority
0000ba  2009              MOVS     r0,#9                 ;212
0000bc  f7fffffe          BL       __NVIC_SetPriority
0000c0  2009              MOVS     r0,#9                 ;213
0000c2  e045              B        |L16.336|
0000c4  6810              LDR      r0,[r2,#0]            ;217
0000c6  4308              ORRS     r0,r0,r1              ;217
0000c8  6010              STR      r0,[r2,#0]            ;217
0000ca  f7fffffe          BL       __NVIC_GetPriorityGrouping
0000ce  2201              MOVS     r2,#1                 ;219
0000d0  4611              MOV      r1,r2                 ;219
0000d2  6120              STR      r0,[r4,#0x10]         ;219  ; prioritygroup
0000d4  f7fffffe          BL       NVIC_EncodePriority
0000d8  4601              MOV      r1,r0                 ;219
0000da  6160              STR      r0,[r4,#0x14]         ;220  ; priority
0000dc  200a              MOVS     r0,#0xa               ;220
0000de  f7fffffe          BL       __NVIC_SetPriority
0000e2  200a              MOVS     r0,#0xa               ;221
0000e4  e034              B        |L16.336|
0000e6  6810              LDR      r0,[r2,#0]            ;227
0000e8  4308              ORRS     r0,r0,r1              ;227
0000ea  6010              STR      r0,[r2,#0]            ;227
0000ec  f7fffffe          BL       __NVIC_GetPriorityGrouping
0000f0  2201              MOVS     r2,#1                 ;229
0000f2  4611              MOV      r1,r2                 ;229
0000f4  6120              STR      r0,[r4,#0x10]         ;229  ; prioritygroup
0000f6  f7fffffe          BL       NVIC_EncodePriority
0000fa  4601              MOV      r1,r0                 ;229
0000fc  6160              STR      r0,[r4,#0x14]         ;232  ; priority
0000fe  e00b              B        |L16.280|
000100  6818              LDR      r0,[r3,#0]
000102  4308              ORRS     r0,r0,r1
000104  6018              STR      r0,[r3,#0]
;;;237    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
000106  f7fffffe          BL       __NVIC_GetPriorityGrouping
;;;238    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
00010a  2201              MOVS     r2,#1
00010c  4611              MOV      r1,r2
00010e  6120              STR      r0,[r4,#0x10]  ; prioritygroup
000110  f7fffffe          BL       NVIC_EncodePriority
;;;239    			NVIC_SetPriority(EXTI9_5_IRQn,3);
000114  2103              MOVS     r1,#3
000116  6160              STR      r0,[r4,#0x14]  ; priority
                  |L16.280|
000118  2017              MOVS     r0,#0x17              ;230
00011a  f7fffffe          BL       __NVIC_SetPriority
00011e  2017              MOVS     r0,#0x17              ;231
000120  e016              B        |L16.336|
                  |L16.290|
000122  e019              B        |L16.344|
;;;240    		  NVIC_EnableIRQ(EXTI9_5_IRQn);
;;;241    		break;
;;;242    			
;;;243    		case 10:
;;;244    		case 11:
;;;245    			SYSCFG->EXTICR[2]|= EXTI_port_set;
000124  6818              LDR      r0,[r3,#0]
000126  4308              ORRS     r0,r0,r1
000128  6018              STR      r0,[r3,#0]
;;;246    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
;;;247    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
;;;248    			NVIC_SetPriority(EXTI15_10_IRQn,3);
;;;249    		  NVIC_EnableIRQ(EXTI15_10_IRQn);
;;;250    		break;
00012a  e004              B        |L16.310|
;;;251    		
;;;252    		case 12:
;;;253    		case 13:
;;;254        case 14:
;;;255    		case 15:
;;;256    			SYSCFG->EXTICR[3]|= EXTI_port_set;
00012c  480c              LDR      r0,|L16.352|
00012e  300c              ADDS     r0,r0,#0xc
000130  6802              LDR      r2,[r0,#0]
000132  430a              ORRS     r2,r2,r1
000134  6002              STR      r2,[r0,#0]
                  |L16.310|
;;;257    			prioritygroup = NVIC_GetPriorityGrouping(); // will return 5
000136  f7fffffe          BL       __NVIC_GetPriorityGrouping
;;;258    			priority = NVIC_EncodePriority(prioritygroup, 1, 1 ); // Pri=1 , SubPri=1
00013a  2201              MOVS     r2,#1
00013c  4611              MOV      r1,r2
00013e  6120              STR      r0,[r4,#0x10]  ; prioritygroup
000140  f7fffffe          BL       NVIC_EncodePriority
;;;259    			NVIC_SetPriority(EXTI15_10_IRQn,3);
000144  6160              STR      r0,[r4,#0x14]  ; priority
000146  2103              MOVS     r1,#3
000148  2028              MOVS     r0,#0x28
00014a  f7fffffe          BL       __NVIC_SetPriority
;;;260    		  NVIC_EnableIRQ(EXTI15_10_IRQn);
00014e  2028              MOVS     r0,#0x28
                  |L16.336|
000150  e8bd4070          POP      {r4-r6,lr}
000154  f7ffbffe          B.W      __NVIC_EnableIRQ
                  |L16.344|
;;;261    		break;
;;;262    	}
;;;263    }
000158  bd70              POP      {r4-r6,pc}
;;;264    
                          ENDP

00015a  0000              DCW      0x0000
                  |L16.348|
                          DCD      ||.data||
                  |L16.352|
                          DCD      0x40013808

                          AREA ||i.gpio_set_mode||, CODE, READONLY, ALIGN=2

                  gpio_set_mode PROC
;;;79     
;;;80     void gpio_set_mode(Pin pin, PinMode mode) {
000000  b570              PUSH     {r4-r6,lr}
;;;81     	// Sets the output mode of a pin.
;;;82     	
;;;83     	// If the clock for the pin's port needs to be enabled, it
;;;84     	// should be done here.
;;;85     	
;;;86     	// The modes configure the GPIO pin as follows:
;;;87     	//  - Reset:    resets to a default state.
;;;88     	//  - Input:    sets as a high impedance input.
;;;89     	//  - Output:   sets as a push-pull output.
;;;90     	//  - PullUp:   enables the internal pull-up resistor
;;;91     	//              with the pin configured as an input, and
;;;92     	//              sets the output to logic high (through
;;;93     	//              the pull-up resistor).
;;;94     	//  - PullDown: enables the internal pull-down resistor
;;;95     	//              with the pin configured as an input, and
;;;96     	//              sets the output to logic low (through the
;;;97     	//              pull-down).
;;;98     	
;;;99     	GPIO_TypeDef* p = GET_PORT(pin);
;;;100    	uint32_t pin_index = GET_PIN_INDEX(pin);
;;;101    	RCC->AHB1ENR|=1UL<<GET_PORT_INDEX(pin);//enable clock output
000002  4b20              LDR      r3,|L17.132|
000004  4a1e              LDR      r2,|L17.128|
000006  1404              ASRS     r4,r0,#16             ;99
000008  681e              LDR      r6,[r3,#0]
00000a  eb022284          ADD      r2,r2,r4,LSL #10      ;99
00000e  2501              MOVS     r5,#1
000010  40a5              LSLS     r5,r5,r4
000012  432e              ORRS     r6,r6,r5
000014  601e              STR      r6,[r3,#0]
;;;102    	// Enable clock for interrupts
;;;103    	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
000016  4b1b              LDR      r3,|L17.132|
000018  3314              ADDS     r3,r3,#0x14
00001a  681c              LDR      r4,[r3,#0]
00001c  f4444480          ORR      r4,r4,#0x4000
000020  601c              STR      r4,[r3,#0]
;;;104    	// Enable debug in low-power mode
;;;105    	DBGMCU->CR |= DBGMCU_CR_DBG_SLEEP | DBGMCU_CR_DBG_STOP | DBGMCU_CR_DBG_STANDBY;
000022  4b19              LDR      r3,|L17.136|
000024  685c              LDR      r4,[r3,#4]
000026  f0440407          ORR      r4,r4,#7
00002a  605c              STR      r4,[r3,#4]
00002c  0600              LSLS     r0,r0,#24             ;100
00002e  2303              MOVS     r3,#3                 ;80
;;;106    
;;;107    	switch(mode) {
;;;108    		case Reset:
;;;109    			MODIFY_REG(p->MODER, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2));  
000030  0dc0              LSRS     r0,r0,#23
000032  4083              LSLS     r3,r3,r0
000034  2401              MOVS     r4,#1                 ;101
;;;110    			MODIFY_REG(p->PUPDR, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2));  
;;;111    			break;
;;;112    		case Input:
;;;113    			MODIFY_REG(p->MODER, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2));  
;;;114    			MODIFY_REG(p->PUPDR, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2));  
;;;115    			break;
;;;116    		case Output:
;;;117    			MODIFY_REG(p->MODER, 3UL<<((pin_index)*2), 1UL<<((pin_index)*2)); 
000036  4084              LSLS     r4,r4,r0
000038  2905              CMP      r1,#5                 ;107
00003a  d215              BCS      |L17.104|
00003c  e8dff001          TBB      [pc,r1]               ;107
000040  0303060d          DCB      0x03,0x03,0x06,0x0d
000044  1500              DCB      0x15,0x00
000046  6810              LDR      r0,[r2,#0]            ;109
000048  4398              BICS     r0,r0,r3              ;109
00004a  e002              B        |L17.82|
00004c  6810              LDR      r0,[r2,#0]
00004e  4398              BICS     r0,r0,r3
000050  4320              ORRS     r0,r0,r4
                  |L17.82|
000052  6010              STR      r0,[r2,#0]            ;109
000054  68d0              LDR      r0,[r2,#0xc]          ;110
000056  4398              BICS     r0,r0,r3              ;110
000058  e005              B        |L17.102|
;;;118    			MODIFY_REG(p->PUPDR, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2)); 
;;;119    			break;
;;;120    		case PullUp:
;;;121    			MODIFY_REG(p->MODER, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2));  
00005a  6810              LDR      r0,[r2,#0]
00005c  4398              BICS     r0,r0,r3
00005e  6010              STR      r0,[r2,#0]
;;;122    			MODIFY_REG(p->PUPDR, 3UL<<((pin_index)*2), 1UL<<((pin_index)*2)); 
000060  68d0              LDR      r0,[r2,#0xc]
000062  4398              BICS     r0,r0,r3
000064  4320              ORRS     r0,r0,r4
                  |L17.102|
000066  60d0              STR      r0,[r2,#0xc]
                  |L17.104|
;;;123    			break;
;;;124    		case PullDown:
;;;125    			MODIFY_REG(p->MODER, 3UL<<((pin_index)*2), 0UL<<((pin_index)*2));  
;;;126    			MODIFY_REG(p->PUPDR, 3UL<<((pin_index)*2), 10UL<<((pin_index)*2)); 
;;;127    			break;
;;;128    	}
;;;129    }
000068  bd70              POP      {r4-r6,pc}
00006a  6811              LDR      r1,[r2,#0]            ;125
00006c  4399              BICS     r1,r1,r3              ;125
00006e  6011              STR      r1,[r2,#0]            ;125
000070  68d1              LDR      r1,[r2,#0xc]          ;126
000072  4399              BICS     r1,r1,r3              ;126
000074  230a              MOVS     r3,#0xa               ;126
000076  4083              LSLS     r3,r3,r0              ;126
000078  4319              ORRS     r1,r1,r3              ;126
00007a  60d1              STR      r1,[r2,#0xc]          ;126
00007c  bd70              POP      {r4-r6,pc}
;;;130    
                          ENDP

00007e  0000              DCW      0x0000
                  |L17.128|
                          DCD      0x40020000
                  |L17.132|
                          DCD      0x40023830
                  |L17.136|
                          DCD      0xe0042000

                          AREA ||i.gpio_set_range||, CODE, READONLY, ALIGN=2

                  gpio_set_range PROC
;;;40     
;;;41     void gpio_set_range(Pin pin_base, int count, int value) {
000000  b530              PUSH     {r4,r5,lr}
;;;42     	// Sets a range of pins to the specified value.
;;;43     	
;;;44     	// This can be used to write to an entire port, or just
;;;45     	// a subset of the (consecutive) pins on a port.
;;;46     	
;;;47     	// The output pin_base should be set to the LSB of
;;;48     	// value. Pin (pin_base + 1) should be LSB + 1, etc.
;;;49     	
;;;50     	// The mask for the value parameter should be:
;;;51     	// ((1 << count) - 1).
;;;52     	
;;;53       GPIO_TypeDef* p = GET_PORT(pin_base);
000002  4c07              LDR      r4,|L18.32|
000004  1403              ASRS     r3,r0,#16
000006  eb042383          ADD      r3,r4,r3,LSL #10
;;;54     	uint32_t pin_index = GET_PIN_INDEX(pin_base);
;;;55     	
;;;56     	MODIFY_REG(p->ODR,((1UL<<count)-1)<<pin_index,value<<pin_index);
00000a  695c              LDR      r4,[r3,#0x14]
00000c  2501              MOVS     r5,#1
00000e  408d              LSLS     r5,r5,r1
000010  1e6d              SUBS     r5,r5,#1
000012  4085              LSLS     r5,r5,r0
000014  43ac              BICS     r4,r4,r5
000016  4082              LSLS     r2,r2,r0
000018  4314              ORRS     r4,r4,r2
00001a  615c              STR      r4,[r3,#0x14]
;;;57     }
00001c  bd30              POP      {r4,r5,pc}
;;;58     
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      0x40020000

                          AREA ||i.gpio_set_trigger||, CODE, READONLY, ALIGN=2

                  gpio_set_trigger PROC
;;;130    
;;;131    void gpio_set_trigger(Pin pin, TriggerMode trig) {
000000  2301              MOVS     r3,#1
;;;132    	// Sets the interrupt trigger for the specified pin.
;;;133    	
;;;134    	// The modes are as follows:
;;;135    	//  - None:    Disable the trigger.
;;;136    	//  - Rising:  Trigger on transition from logic low to
;;;137    	//             high.
;;;138    	//  - Falling: Trigger on transition from logic high to
;;;139    	//             low.
;;;140    	
;;;141    	uint32_t pin_index = GET_PIN_INDEX(pin);
;;;142    	
;;;143    	switch(trig){
;;;144    		case None:
;;;145    			EXTI->IMR &= ~(1<<pin_index);
000002  4a10              LDR      r2,|L19.68|
000004  4083              LSLS     r3,r3,r0
000006  b189              CBZ      r1,|L19.44|
000008  2901              CMP      r1,#1                 ;143
00000a  d013              BEQ      |L19.52|
00000c  2902              CMP      r1,#2                 ;143
00000e  d10c              BNE      |L19.42|
;;;146    		break;
;;;147    		case Rising:
;;;148    			EXTI->IMR |= (1<<pin_index);
;;;149    			EXTI->RTSR|= (1<<pin_index);
;;;150    		break;
;;;151    		case Falling:
;;;152    			EXTI->IMR |= (1<<pin_index);
000010  6810              LDR      r0,[r2,#0]
000012  4318              ORRS     r0,r0,r3
000014  6010              STR      r0,[r2,#0]
;;;153    			EXTI->FTSR|= (1<<pin_index);
000016  480b              LDR      r0,|L19.68|
000018  300c              ADDS     r0,r0,#0xc
00001a  6801              LDR      r1,[r0,#0]
00001c  4319              ORRS     r1,r1,r3
00001e  6001              STR      r1,[r0,#0]
;;;154    			EXTI->PR 	&= (0<<pin_index);
000020  4808              LDR      r0,|L19.68|
000022  3014              ADDS     r0,r0,#0x14
000024  6801              LDR      r1,[r0,#0]
000026  2100              MOVS     r1,#0
                  |L19.40|
000028  6001              STR      r1,[r0,#0]
                  |L19.42|
;;;155    		break;
;;;156    	}
;;;157    }
00002a  4770              BX       lr
                  |L19.44|
00002c  6810              LDR      r0,[r2,#0]            ;145
00002e  4398              BICS     r0,r0,r3              ;145
000030  6010              STR      r0,[r2,#0]            ;145
000032  4770              BX       lr
                  |L19.52|
000034  6810              LDR      r0,[r2,#0]            ;148
000036  4318              ORRS     r0,r0,r3              ;148
000038  6010              STR      r0,[r2,#0]            ;148
00003a  4802              LDR      r0,|L19.68|
00003c  3008              ADDS     r0,r0,#8              ;149
00003e  6801              LDR      r1,[r0,#0]            ;149
000040  4319              ORRS     r1,r1,r3              ;149
000042  e7f1              B        |L19.40|
;;;158    
                          ENDP

                  |L19.68|
                          DCD      0x40013c00

                          AREA ||i.gpio_toggle||, CODE, READONLY, ALIGN=1

                  gpio_toggle PROC
;;;12     
;;;13     void gpio_toggle(Pin pin) {
000000  b500              PUSH     {lr}
000002  4603              MOV      r3,r0
;;;14     	// Toggles a GPIO pin.
;;;15     	// In the absence of a pin toggle register, can be easily
;;;16     	// implemented with:
;;;17     	// gpio_set(pin, !gpio_get(pin));
;;;18     	
;;;19     	gpio_set(pin, !gpio_get(pin));
000004  f7fffffe          BL       gpio_get
000008  b128              CBZ      r0,|L20.22|
00000a  2100              MOVS     r1,#0
                  |L20.12|
00000c  4618              MOV      r0,r3
00000e  f85deb04          POP      {lr}
000012  f7ffbffe          B.W      gpio_set
                  |L20.22|
000016  2101              MOVS     r1,#1
000018  e7f8              B        |L20.12|
;;;20     }
;;;21     
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  IRQ_status
                          DCD      0x00000000
                  IRQ_port_num
                          DCD      0x00000000
                  IRQ_pin_index
                          DCD      0x00000000
                  EXTI_port_set
                          DCD      0x00000000
                  prioritygroup
                          DCD      0x00000000
                  priority
                          DCD      0x00000000
                  GPIO_callback
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "drivers\\gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_5c9fa751____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___6_gpio_c_5c9fa751____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_5c9fa751____REVSH|
#line 223
|__asm___6_gpio_c_5c9fa751____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_gpio_c_5c9fa751____RRX|
#line 410
|__asm___6_gpio_c_5c9fa751____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
