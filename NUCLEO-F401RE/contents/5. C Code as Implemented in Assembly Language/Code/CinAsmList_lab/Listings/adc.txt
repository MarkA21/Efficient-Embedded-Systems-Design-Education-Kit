; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\adc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\adc.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\adc.crf drivers\adc.c]
                          THUMB

                          AREA ||i._ADC_ConfigChannel||, CODE, READONLY, ALIGN=2

                  _ADC_ConfigChannel PROC
;;;618    
;;;619    void _ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig) {
000000  b530              PUSH     {r4,r5,lr}
;;;620      uint32_t counter = 0;
;;;621      
;;;622      /* Process locked */
;;;623    	if (hadc->Lock !=	HAL_LOCKED)
000002  f8902038          LDRB     r2,[r0,#0x38]
000006  2a01              CMP      r2,#1
000008  d002              BEQ      |L1.16|
;;;624    	{
;;;625    		hadc->Lock =	HAL_LOCKED;
00000a  2201              MOVS     r2,#1
00000c  f8802038          STRB     r2,[r0,#0x38]
                  |L1.16|
;;;626    	}
;;;627    
;;;628        
;;;629      /* if ADC_Channel_10 ... ADC_Channel_18 is selected */
;;;630      if (sConfig->Channel > ADC_CHANNEL_9)
;;;631      {
;;;632        /* Clear the old sample time */
;;;633        hadc->Instance->SMPR1 &= ~ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel);
000010  680c              LDR      r4,[r1,#0]
000012  2207              MOVS     r2,#7
000014  6803              LDR      r3,[r0,#0]            ;630
000016  2c09              CMP      r4,#9                 ;630
000018  d911              BLS      |L1.62|
00001a  68dd              LDR      r5,[r3,#0xc]
00001c  3c0a              SUBS     r4,r4,#0xa
00001e  eb040444          ADD      r4,r4,r4,LSL #1
000022  40a2              LSLS     r2,r2,r4
000024  4395              BICS     r5,r5,r2
000026  60dd              STR      r5,[r3,#0xc]
;;;634        
;;;635        /* Set the new sample time */
;;;636        hadc->Instance->SMPR1 |= ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel);
000028  780b              LDRB     r3,[r1,#0]
00002a  688a              LDR      r2,[r1,#8]
00002c  3b0a              SUBS     r3,r3,#0xa
00002e  eb030343          ADD      r3,r3,r3,LSL #1
000032  409a              LSLS     r2,r2,r3
000034  6803              LDR      r3,[r0,#0]
000036  68dc              LDR      r4,[r3,#0xc]
000038  4322              ORRS     r2,r2,r4
00003a  60da              STR      r2,[r3,#0xc]
00003c  e00e              B        |L1.92|
                  |L1.62|
;;;637      }
;;;638      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;639      {
;;;640        /* Clear the old sample time */
;;;641        hadc->Instance->SMPR2 &= ~ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel);
00003e  691d              LDR      r5,[r3,#0x10]
000040  eb040444          ADD      r4,r4,r4,LSL #1
000044  40a2              LSLS     r2,r2,r4
000046  4395              BICS     r5,r5,r2
000048  611d              STR      r5,[r3,#0x10]
;;;642        
;;;643        /* Set the new sample time */
;;;644        hadc->Instance->SMPR2 |= ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel);
00004a  780a              LDRB     r2,[r1,#0]
00004c  688b              LDR      r3,[r1,#8]
00004e  eb020242          ADD      r2,r2,r2,LSL #1
000052  4093              LSLS     r3,r3,r2
000054  6802              LDR      r2,[r0,#0]
000056  6914              LDR      r4,[r2,#0x10]
000058  4323              ORRS     r3,r3,r4
00005a  6113              STR      r3,[r2,#0x10]
                  |L1.92|
;;;645      }
;;;646      
;;;647      /* For Rank 1 to 6 */
;;;648      if (sConfig->Rank < 7)
00005c  684a              LDR      r2,[r1,#4]
;;;649      {
;;;650        /* Clear the old SQx bits for the selected rank */
;;;651        hadc->Instance->SQR3 &= ~ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank);
00005e  231f              MOVS     r3,#0x1f
000060  2a07              CMP      r2,#7                 ;648
000062  d213              BCS      |L1.140|
000064  6804              LDR      r4,[r0,#0]
000066  6b65              LDR      r5,[r4,#0x34]
000068  1e52              SUBS     r2,r2,#1
00006a  eb020282          ADD      r2,r2,r2,LSL #2
00006e  4093              LSLS     r3,r3,r2
000070  439d              BICS     r5,r5,r3
000072  6365              STR      r5,[r4,#0x34]
;;;652        
;;;653        /* Set the SQx bits for the selected rank */
;;;654        hadc->Instance->SQR3 |= ADC_SQR3_RK(sConfig->Channel, sConfig->Rank);
000074  790b              LDRB     r3,[r1,#4]
000076  880a              LDRH     r2,[r1,#0]
000078  1e5b              SUBS     r3,r3,#1
00007a  b292              UXTH     r2,r2
00007c  eb030383          ADD      r3,r3,r3,LSL #2
000080  409a              LSLS     r2,r2,r3
000082  6803              LDR      r3,[r0,#0]
000084  6b5c              LDR      r4,[r3,#0x34]
000086  4322              ORRS     r2,r2,r4
000088  635a              STR      r2,[r3,#0x34]
00008a  e027              B        |L1.220|
                  |L1.140|
;;;655      }
;;;656      /* For Rank 7 to 12 */
;;;657      else if (sConfig->Rank < 13)
00008c  6804              LDR      r4,[r0,#0]
00008e  2a0d              CMP      r2,#0xd
000090  d212              BCS      |L1.184|
;;;658      {
;;;659        /* Clear the old SQx bits for the selected rank */
;;;660        hadc->Instance->SQR2 &= ~ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank);
000092  6b25              LDR      r5,[r4,#0x30]
000094  1fd2              SUBS     r2,r2,#7
000096  eb020282          ADD      r2,r2,r2,LSL #2
00009a  4093              LSLS     r3,r3,r2
00009c  439d              BICS     r5,r5,r3
00009e  6325              STR      r5,[r4,#0x30]
;;;661        
;;;662        /* Set the SQx bits for the selected rank */
;;;663        hadc->Instance->SQR2 |= ADC_SQR2_RK(sConfig->Channel, sConfig->Rank);
0000a0  790b              LDRB     r3,[r1,#4]
0000a2  880a              LDRH     r2,[r1,#0]
0000a4  1fdb              SUBS     r3,r3,#7
0000a6  b292              UXTH     r2,r2
0000a8  eb030383          ADD      r3,r3,r3,LSL #2
0000ac  409a              LSLS     r2,r2,r3
0000ae  6803              LDR      r3,[r0,#0]
0000b0  6b1c              LDR      r4,[r3,#0x30]
0000b2  4322              ORRS     r2,r2,r4
0000b4  631a              STR      r2,[r3,#0x30]
0000b6  e011              B        |L1.220|
                  |L1.184|
;;;664      }
;;;665      /* For Rank 13 to 16 */
;;;666      else
;;;667      {
;;;668        /* Clear the old SQx bits for the selected rank */
;;;669        hadc->Instance->SQR1 &= ~ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank);
0000b8  6ae5              LDR      r5,[r4,#0x2c]
0000ba  3a0d              SUBS     r2,r2,#0xd
0000bc  eb020282          ADD      r2,r2,r2,LSL #2
0000c0  4093              LSLS     r3,r3,r2
0000c2  439d              BICS     r5,r5,r3
0000c4  62e5              STR      r5,[r4,#0x2c]
;;;670        
;;;671        /* Set the SQx bits for the selected rank */
;;;672        hadc->Instance->SQR1 |= ADC_SQR1_RK(sConfig->Channel, sConfig->Rank);
0000c6  790b              LDRB     r3,[r1,#4]
0000c8  880a              LDRH     r2,[r1,#0]
0000ca  3b0d              SUBS     r3,r3,#0xd
0000cc  b292              UXTH     r2,r2
0000ce  eb030383          ADD      r3,r3,r3,LSL #2
0000d2  409a              LSLS     r2,r2,r3
0000d4  6803              LDR      r3,[r0,#0]
0000d6  6adc              LDR      r4,[r3,#0x2c]
0000d8  4322              ORRS     r2,r2,r4
0000da  62da              STR      r2,[r3,#0x2c]
                  |L1.220|
;;;673      }
;;;674      
;;;675      /* if ADC1 Channel_18 is selected enable VBAT Channel */
;;;676      if ((hadc->Instance == ADC1) && (sConfig->Channel == ADC_CHANNEL_VBAT))
0000dc  4a16              LDR      r2,|L1.312|
0000de  6803              LDR      r3,[r0,#0]
0000e0  4293              CMP      r3,r2
0000e2  d108              BNE      |L1.246|
0000e4  680b              LDR      r3,[r1,#0]
0000e6  2b12              CMP      r3,#0x12
0000e8  d105              BNE      |L1.246|
;;;677      {
;;;678        /* Enable the VBAT channel*/
;;;679        ADC->CCR |= ADC_CCR_VBATE;
0000ea  f8d23304          LDR      r3,[r2,#0x304]
0000ee  f4430380          ORR      r3,r3,#0x400000
0000f2  f8c23304          STR      r3,[r2,#0x304]
                  |L1.246|
;;;680      }
;;;681      
;;;682      /* if ADC1 Channel_16 or Channel_17 is selected enable TSVREFE Channel(Temperature sensor and VREFINT) */
;;;683      if ((hadc->Instance == ADC1) && ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) || (sConfig->Channel == ADC_CHANNEL_VREFINT)))
0000f6  6803              LDR      r3,[r0,#0]
0000f8  4293              CMP      r3,r2
0000fa  d119              BNE      |L1.304|
0000fc  680b              LDR      r3,[r1,#0]
0000fe  2b10              CMP      r3,#0x10
000100  d001              BEQ      |L1.262|
000102  2b11              CMP      r3,#0x11
000104  d114              BNE      |L1.304|
                  |L1.262|
;;;684      {
;;;685        /* Enable the TSVREFE channel*/
;;;686        ADC->CCR |= ADC_CCR_TSVREFE;
000106  f8d23304          LDR      r3,[r2,#0x304]
00010a  f4430300          ORR      r3,r3,#0x800000
00010e  f8c23304          STR      r3,[r2,#0x304]
;;;687        
;;;688        if((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
000112  6809              LDR      r1,[r1,#0]
000114  2910              CMP      r1,#0x10
000116  d10b              BNE      |L1.304|
;;;689        {
;;;690          /* Delay for temperature sensor stabilization time */
;;;691          /* Compute number of CPU cycles to wait for */
;;;692          counter = (((uint32_t) 10) * (SystemCoreClock / 1000000));
000118  4908              LDR      r1,|L1.316|
00011a  4a09              LDR      r2,|L1.320|
00011c  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00011e  fbb1f1f2          UDIV     r1,r1,r2
000122  eb010181          ADD      r1,r1,r1,LSL #2
000126  0049              LSLS     r1,r1,#1
;;;693          while(counter != 0)
000128  e000              B        |L1.300|
                  |L1.298|
00012a  1e49              SUBS     r1,r1,#1
                  |L1.300|
00012c  2900              CMP      r1,#0
00012e  d1fc              BNE      |L1.298|
                  |L1.304|
;;;694          {
;;;695            counter--;
;;;696          }
;;;697        }
;;;698      }
;;;699      
;;;700      /* Process unlocked */
;;;701      hadc->Lock =	HAL_UNLOCKED;  
000130  2100              MOVS     r1,#0
000132  f8801038          STRB     r1,[r0,#0x38]
;;;702    }
000136  bd30              POP      {r4,r5,pc}
;;;703    
                          ENDP

                  |L1.312|
                          DCD      0x40012000
                  |L1.316|
                          DCD      SystemCoreClock
                  |L1.320|
                          DCD      0x000f4240

                          AREA ||i._ADC_GetValue||, CODE, READONLY, ALIGN=1

                  _ADC_GetValue PROC
;;;553    
;;;554    uint32_t _ADC_GetValue(ADC_HandleTypeDef* hadc) {       
000000  6800              LDR      r0,[r0,#0]
;;;555      /* Return the selected ADC converted value */ 
;;;556      return hadc->Instance->DR;
000002  6cc0              LDR      r0,[r0,#0x4c]
;;;557    }
000004  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i._ADC_Init||, CODE, READONLY, ALIGN=1

                  _ADC_Init PROC
;;;207    
;;;208    void _ADC_Init(ADC_HandleTypeDef* hadc) {	    
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;209      if(hadc->State == HAL_ADC_STATE_RESET)
000004  f8900039          LDRB     r0,[r0,#0x39]
000008  2500              MOVS     r5,#0
00000a  b908              CBNZ     r0,|L3.16|
;;;210      {
;;;211        /* Allocate lock resource and initialize it */
;;;212        hadc->Lock = HAL_UNLOCKED;    
00000c  f8845038          STRB     r5,[r4,#0x38]
                  |L3.16|
;;;213      }
;;;214      
;;;215      /* Initialize the ADC state */
;;;216      hadc->State = HAL_ADC_STATE_BUSY;
000010  2002              MOVS     r0,#2
000012  f8840039          STRB     r0,[r4,#0x39]
;;;217      
;;;218      /* Set ADC parameters */
;;;219      local_ADC_Init(hadc); 
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       local_ADC_Init
;;;220      
;;;221      /* Initialize the ADC state */
;;;222      hadc->State = HAL_ADC_STATE_READY;
00001c  2001              MOVS     r0,#1
00001e  f8840039          STRB     r0,[r4,#0x39]
;;;223    
;;;224      /* Release Lock */
;;;225      hadc->Lock = HAL_UNLOCKED; 
000022  f8845038          STRB     r5,[r4,#0x38]
;;;226    }
000026  bd70              POP      {r4-r6,pc}
;;;227    
                          ENDP


                          AREA ||i._ADC_PollForConversion||, CODE, READONLY, ALIGN=1

                  _ADC_PollForConversion PROC
;;;560    
;;;561    int _ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout) {
000000  b510              PUSH     {r4,lr}
;;;562      uint32_t tickstart = 0;
;;;563     
;;;564      /* Verification that ADC configuration is compliant with polling for      */
;;;565      /* each conversion:                                                       */
;;;566      /* Particular case is ADC configured in DMA mode and ADC sequencer with   */
;;;567      /* several ranks and polling for end of each conversion.                  */
;;;568      /* For code simplicity sake, this particular case is generalized to       */
;;;569      /* ADC configured in DMA mode and polling for end of each conversion.     */
;;;570      if (_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_EOCS) &&
000002  6802              LDR      r2,[r0,#0]
000004  6893              LDR      r3,[r2,#8]
000006  055c              LSLS     r4,r3,#21
000008  f04f0300          MOV      r3,#0
00000c  d504              BPL      |L4.24|
;;;571          _IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA)    )
00000e  6894              LDR      r4,[r2,#8]
000010  05e4              LSLS     r4,r4,#23
000012  d501              BPL      |L4.24|
;;;572      {
;;;573        /* Update ADC state machine to error */
;;;574        hadc->State = HAL_ADC_STATE_ERROR;
000014  2104              MOVS     r1,#4
;;;575        
;;;576        /* Process unlocked */
;;;577        hadc->Lock =	HAL_UNLOCKED;  
;;;578        
;;;579        return 0;
000016  e012              B        |L4.62|
                  |L4.24|
;;;580      }
;;;581    
;;;582      /* Get tick */ 
;;;583      tickstart = Timeout *10 ;
000018  eb010181          ADD      r1,r1,r1,LSL #2
00001c  0049              LSLS     r1,r1,#1
;;;584    
;;;585      /* Check End of conversion flag */
;;;586      while(!(_ADC_GET_FLAG(hadc, ADC_FLAG_EOC)))
00001e  e001              B        |L4.36|
                  |L4.32|
;;;587      {
;;;588        /* Check for the Timeout */
;;;589        if(tickstart == 0)
000020  b161              CBZ      r1,|L4.60|
000022  1e49              SUBS     r1,r1,#1
                  |L4.36|
000024  6814              LDR      r4,[r2,#0]            ;586
000026  07a4              LSLS     r4,r4,#30             ;586
000028  d5fa              BPL      |L4.32|
;;;590        {      
;;;591            hadc->State= HAL_ADC_STATE_TIMEOUT;
;;;592            /* Process unlocked */
;;;593            hadc->Lock =	HAL_UNLOCKED;  
;;;594            return 0;      
;;;595        }
;;;596    		tickstart--;
;;;597      }
;;;598      
;;;599      /* Check if an injected conversion is ready */
;;;600      if(hadc->State == HAL_ADC_STATE_EOC_INJ)
00002a  f8901039          LDRB     r1,[r0,#0x39]
00002e  2925              CMP      r1,#0x25
000030  d00b              BEQ      |L4.74|
;;;601      {
;;;602        /* Change ADC state */
;;;603        hadc->State = HAL_ADC_STATE_EOC_INJ_REG;  
;;;604      }
;;;605      else
;;;606      {
;;;607        /* Change ADC state */
;;;608        hadc->State = HAL_ADC_STATE_EOC_REG;
000032  2115              MOVS     r1,#0x15
                  |L4.52|
000034  f8801039          STRB     r1,[r0,#0x39]
;;;609      }
;;;610      
;;;611      /* Return ADC state */
;;;612      return 1;
000038  2001              MOVS     r0,#1
;;;613    }
00003a  bd10              POP      {r4,pc}
                  |L4.60|
00003c  2103              MOVS     r1,#3                 ;591
                  |L4.62|
00003e  f8801039          STRB     r1,[r0,#0x39]         ;591
000042  f8803038          STRB     r3,[r0,#0x38]         ;593
000046  2000              MOVS     r0,#0                 ;594
000048  bd10              POP      {r4,pc}
                  |L4.74|
00004a  2135              MOVS     r1,#0x35              ;603
00004c  e7f2              B        |L4.52|
;;;614    
                          ENDP


                          AREA ||i._ADC_Start||, CODE, READONLY, ALIGN=2

                  _ADC_Start PROC
;;;705    
;;;706    void _ADC_Start(ADC_HandleTypeDef* hadc) {
000000  f8901038          LDRB     r1,[r0,#0x38]
;;;707      uint32_t counter = 0;  
;;;708      
;;;709      /* Process locked */
;;;710      if (hadc->Lock !=	HAL_LOCKED)
000004  2901              CMP      r1,#1
000006  d002              BEQ      |L5.14|
;;;711    	{
;;;712    		hadc->Lock =	HAL_LOCKED;
000008  2101              MOVS     r1,#1
00000a  f8801038          STRB     r1,[r0,#0x38]
                  |L5.14|
;;;713    	}
;;;714      
;;;715      /* Check if an injected conversion is ongoing */
;;;716      if(hadc->State == HAL_ADC_STATE_BUSY_INJ)
00000e  f8901039          LDRB     r1,[r0,#0x39]
000012  2922              CMP      r1,#0x22
000014  d007              BEQ      |L5.38|
;;;717      {
;;;718        /* Change ADC state */
;;;719        hadc->State = HAL_ADC_STATE_BUSY_INJ_REG;  
;;;720      }
;;;721      else
;;;722      {
;;;723        /* Change ADC state */
;;;724        hadc->State = HAL_ADC_STATE_BUSY_REG;
000016  2112              MOVS     r1,#0x12
                  |L5.24|
000018  f8801039          STRB     r1,[r0,#0x39]
;;;725      } 
;;;726        
;;;727      /* Check if ADC peripheral is disabled in order to enable it and wait during 
;;;728      Tstab time the ADC's stabilization */
;;;729      if((hadc->Instance->CR2 & ADC_CR2_ADON) != ADC_CR2_ADON)
00001c  6801              LDR      r1,[r0,#0]
00001e  688a              LDR      r2,[r1,#8]
000020  07d2              LSLS     r2,r2,#31
000022  d002              BEQ      |L5.42|
000024  e010              B        |L5.72|
                  |L5.38|
000026  2132              MOVS     r1,#0x32              ;719
000028  e7f6              B        |L5.24|
                  |L5.42|
;;;730      {  
;;;731        /* Enable the Peripheral */
;;;732        hadc->Instance->CR2 |=  ADC_CR2_ADON;
00002a  688a              LDR      r2,[r1,#8]
00002c  f0420201          ORR      r2,r2,#1
000030  608a              STR      r2,[r1,#8]
;;;733        
;;;734        /* Delay for ADC stabilization time */
;;;735        /* Compute number of CPU cycles to wait for */
;;;736        counter = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000));
000032  490f              LDR      r1,|L5.112|
000034  4a0f              LDR      r2,|L5.116|
000036  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000038  fbb1f1f2          UDIV     r1,r1,r2
00003c  eb010141          ADD      r1,r1,r1,LSL #1
;;;737        while(counter != 0)
000040  e000              B        |L5.68|
                  |L5.66|
000042  1e49              SUBS     r1,r1,#1
                  |L5.68|
000044  2900              CMP      r1,#0
000046  d1fc              BNE      |L5.66|
                  |L5.72|
;;;738        {
;;;739          counter--;
;;;740        }
;;;741      }
;;;742      
;;;743      /* Process unlocked */
;;;744      hadc->Lock =	HAL_UNLOCKED;  
000048  2100              MOVS     r1,#0
00004a  f8801038          STRB     r1,[r0,#0x38]
;;;745      
;;;746      /* Check if Multimode enabled */
;;;747      if(_IS_BIT_CLR(ADC->CCR, ADC_CCR_MULTI))
00004e  490a              LDR      r1,|L5.120|
000050  f8d12304          LDR      r2,[r1,#0x304]
;;;748      {
;;;749        /* if no external trigger present enable software conversion of regular channels */
;;;750        if((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET) 
;;;751        {
;;;752          /* Enable the selected ADC software conversion for regular group */
;;;753          hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;754        }
;;;755      }
;;;756      else
;;;757      {
;;;758        /* if instance of handle correspond to ADC1 and  no external trigger present enable software conversion of regular channels */
;;;759        if((hadc->Instance == ADC1) && ((hadc->Instance->CR2 & ADC_CR2_EXTEN) == RESET))
000054  6800              LDR      r0,[r0,#0]
000056  06d2              LSLS     r2,r2,#27             ;747
000058  d001              BEQ      |L5.94|
00005a  4288              CMP      r0,r1
00005c  d107              BNE      |L5.110|
                  |L5.94|
00005e  6881              LDR      r1,[r0,#8]
000060  f0115f40          TST      r1,#0x30000000
000064  d103              BNE      |L5.110|
000066  6881              LDR      r1,[r0,#8]            ;753
000068  f0414180          ORR      r1,r1,#0x40000000     ;753
00006c  6081              STR      r1,[r0,#8]            ;753
                  |L5.110|
;;;760        {
;;;761          /* Enable the selected ADC software conversion for regular group */
;;;762            hadc->Instance->CR2 |= (uint32_t)ADC_CR2_SWSTART;
;;;763        }
;;;764      }  
;;;765      
;;;766    }
00006e  4770              BX       lr
;;;767    
                          ENDP

                  |L5.112|
                          DCD      SystemCoreClock
                  |L5.116|
                          DCD      0x000f4240
                  |L5.120|
                          DCD      0x40012000

                          AREA ||i._GPIO_Init||, CODE, READONLY, ALIGN=1

                  _GPIO_Init PROC
;;;385    
;;;386    void _GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;387    	uint32_t position;
;;;388      uint32_t ioposition = 0x00;
;;;389      uint32_t iocurrent = 0x00;
;;;390      uint32_t temp = 0x00;  
;;;391    
;;;392      /* Configure the port pins */
;;;393      for(position = 0; position < 0x10; position++)
000002  2200              MOVS     r2,#0
;;;394      {
;;;395        /* Get the IO position */
;;;396        ioposition = ((uint32_t)0x01) << position;
000004  f04f0c01          MOV      r12,#1
                  |L6.8|
;;;397        /* Get the current IO position */
;;;398        iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
000008  680c              LDR      r4,[r1,#0]
00000a  fa0cf302          LSL      r3,r12,r2             ;396
00000e  401c              ANDS     r4,r4,r3
;;;399    
;;;400        if(iocurrent == ioposition)
000010  429c              CMP      r4,r3
000012  d110              BNE      |L6.54|
;;;401        {
;;;402          /*--------------------- GPIO Mode Configuration ------------------------*/
;;;403          /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
;;;404          temp = GPIOx->MODER;
000014  6804              LDR      r4,[r0,#0]
;;;405          temp &= ~(GPIO_MODER_MODER0 << (position * 2));
000016  0057              LSLS     r7,r2,#1
000018  2503              MOVS     r5,#3
;;;406          temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
00001a  790b              LDRB     r3,[r1,#4]
00001c  40bd              LSLS     r5,r5,r7              ;405
00001e  f0030603          AND      r6,r3,#3
000022  43ac              BICS     r4,r4,r5              ;405
000024  40be              LSLS     r6,r6,r7
000026  4326              ORRS     r6,r6,r4
;;;407          GPIOx->MODER = temp;     
000028  6006              STR      r6,[r0,#0]
;;;408    
;;;409          /* Activate the Pull-up or Pull down resistor for the current IO */
;;;410          temp = GPIOx->PUPDR;
00002a  68c3              LDR      r3,[r0,#0xc]
;;;411          temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2));
;;;412          temp |= ((GPIO_Init->Pull) << (position * 2));
00002c  688c              LDR      r4,[r1,#8]
00002e  43ab              BICS     r3,r3,r5              ;411
000030  40bc              LSLS     r4,r4,r7
000032  431c              ORRS     r4,r4,r3
;;;413          GPIOx->PUPDR = temp;      
000034  60c4              STR      r4,[r0,#0xc]
                  |L6.54|
000036  1c52              ADDS     r2,r2,#1
000038  2a10              CMP      r2,#0x10              ;393
00003a  d3e5              BCC      |L6.8|
;;;414        }
;;;415      }
;;;416    }
00003c  bdf0              POP      {r4-r7,pc}
;;;417    
                          ENDP


                          AREA ||i._adc_read||, CODE, READONLY, ALIGN=2

                  _adc_read PROC
;;;476    
;;;477    uint16_t _adc_read(analogin_s *obj) {
000000  b51f              PUSH     {r0-r4,lr}
;;;478        ADC_ChannelConfTypeDef sConfig;
;;;479    
;;;480        AdcHandle.Instance = (ADC_TypeDef *)(obj->adc);
000002  4c24              LDR      r4,|L7.148|
000004  6801              LDR      r1,[r0,#0]
;;;481    
;;;482        // Configure ADC channel
;;;483        sConfig.Rank         = 1;
000006  2201              MOVS     r2,#1
;;;484        sConfig.SamplingTime = ((uint32_t)0x00000000);
000008  6021              STR      r1,[r4,#0]  ; AdcHandle
00000a  2100              MOVS     r1,#0
00000c  e9cd2101          STRD     r2,r1,[sp,#4]
;;;485        sConfig.Offset       = 0;
;;;486    
;;;487        switch (obj->channel) {
000010  9103              STR      r1,[sp,#0xc]
000012  7a00              LDRB     r0,[r0,#8]
000014  2810              CMP      r0,#0x10
000016  d21e              BCS      |L7.86|
000018  e8dff000          TBB      [pc,r0]
00001c  080a0c0e          DCB      0x08,0x0a,0x0c,0x0e
000020  20222426          DCB      0x20,0x22,0x24,0x26
000024  282a2c2e          DCB      0x28,0x2a,0x2c,0x2e
000028  30323436          DCB      0x30,0x32,0x34,0x36
;;;488            case 0:
;;;489                sConfig.Channel = ADC_CHANNEL_0;
;;;490                break;
00002c  9100              STR      r1,[sp,#0]
00002e  e005              B        |L7.60|
;;;491            case 1:
;;;492                sConfig.Channel = ADC_CHANNEL_1;
;;;493                break;
000030  9200              STR      r2,[sp,#0]
000032  e003              B        |L7.60|
;;;494            case 2:
;;;495                sConfig.Channel = ADC_CHANNEL_2;
000034  2002              MOVS     r0,#2
;;;496                break;
000036  e000              B        |L7.58|
;;;497            case 3:
;;;498                sConfig.Channel = ADC_CHANNEL_3;
000038  2003              MOVS     r0,#3
                  |L7.58|
00003a  9000              STR      r0,[sp,#0]            ;495
                  |L7.60|
;;;499                break;
;;;500            case 4:
;;;501                sConfig.Channel = ADC_CHANNEL_4;
;;;502                break;
;;;503            case 5:
;;;504                sConfig.Channel = ADC_CHANNEL_5;
;;;505                break;
;;;506            case 6:
;;;507                sConfig.Channel = ADC_CHANNEL_6;
;;;508                break;
;;;509            case 7:
;;;510                sConfig.Channel = ADC_CHANNEL_7;
;;;511                break;
;;;512            case 8:
;;;513                sConfig.Channel = ADC_CHANNEL_8;
;;;514                break;
;;;515            case 9:
;;;516                sConfig.Channel = ADC_CHANNEL_9;
;;;517                break;
;;;518            case 10:
;;;519                sConfig.Channel = ADC_CHANNEL_10;
;;;520                break;
;;;521            case 11:
;;;522                sConfig.Channel = ADC_CHANNEL_11;
;;;523                break;
;;;524            case 12:
;;;525                sConfig.Channel = ADC_CHANNEL_12;
;;;526                break;
;;;527            case 13:
;;;528                sConfig.Channel = ADC_CHANNEL_13;
;;;529                break;
;;;530            case 14:
;;;531                sConfig.Channel = ADC_CHANNEL_14;
;;;532                break;
;;;533            case 15:
;;;534                sConfig.Channel = ADC_CHANNEL_15;
;;;535                break;
;;;536            default:
;;;537                return 0;
;;;538        }
;;;539    
;;;540        _ADC_ConfigChannel(&AdcHandle, &sConfig);
00003c  4669              MOV      r1,sp
00003e  4815              LDR      r0,|L7.148|
000040  f7fffffe          BL       _ADC_ConfigChannel
;;;541    
;;;542        _ADC_Start(&AdcHandle); // Start conversion
000044  4813              LDR      r0,|L7.148|
000046  f7fffffe          BL       _ADC_Start
;;;543    
;;;544        // Wait end of conversion and get value
;;;545        if (_ADC_PollForConversion(&AdcHandle, 10) == 1) {
00004a  210a              MOVS     r1,#0xa
00004c  4811              LDR      r0,|L7.148|
00004e  f7fffffe          BL       _ADC_PollForConversion
000052  2801              CMP      r0,#1
000054  d01a              BEQ      |L7.140|
                  |L7.86|
;;;546            return (_ADC_GetValue(&AdcHandle));
;;;547        } else {
;;;548            return 0;
000056  2000              MOVS     r0,#0
                  |L7.88|
;;;549        }
;;;550    }
000058  b004              ADD      sp,sp,#0x10
00005a  bd10              POP      {r4,pc}
00005c  2004              MOVS     r0,#4                 ;501
00005e  e7ec              B        |L7.58|
000060  2005              MOVS     r0,#5                 ;504
000062  e7ea              B        |L7.58|
000064  2006              MOVS     r0,#6                 ;507
000066  e7e8              B        |L7.58|
000068  2007              MOVS     r0,#7                 ;510
00006a  e7e6              B        |L7.58|
00006c  2008              MOVS     r0,#8                 ;513
00006e  e7e4              B        |L7.58|
000070  2009              MOVS     r0,#9                 ;516
000072  e7e2              B        |L7.58|
000074  200a              MOVS     r0,#0xa               ;519
000076  e7e0              B        |L7.58|
000078  200b              MOVS     r0,#0xb               ;522
00007a  e7de              B        |L7.58|
00007c  200c              MOVS     r0,#0xc               ;525
00007e  e7dc              B        |L7.58|
000080  200d              MOVS     r0,#0xd               ;528
000082  e7da              B        |L7.58|
000084  200e              MOVS     r0,#0xe               ;531
000086  e7d8              B        |L7.58|
000088  200f              MOVS     r0,#0xf               ;534
00008a  e7d6              B        |L7.58|
                  |L7.140|
00008c  6820              LDR      r0,[r4,#0]            ;546  ; AdcHandle
00008e  6cc0              LDR      r0,[r0,#0x4c]         ;546
000090  b280              UXTH     r0,r0                 ;546
000092  e7e1              B        |L7.88|
;;;551    
                          ENDP

                  |L7.148|
                          DCD      ||.bss||

                          AREA ||i.adc_init||, CODE, READONLY, ALIGN=2

                  adc_init PROC
;;;65     
;;;66     void adc_init(Pin pin) {	
000000  b570              PUSH     {r4-r6,lr}
;;;67     	switch (pin)
;;;68     	{
;;;69     		case PA_0:
;;;70     			aPA_0 = (analogin_s *)malloc(sizeof(analogin_s));
000002  4c3d              LDR      r4,|L8.248|
000004  4605              MOV      r5,r0                 ;66
000006  f5b03f80          CMP      r0,#0x10000           ;67
00000a  d054              BEQ      |L8.182|
00000c  dc07              BGT      |L8.30|
00000e  2d08              CMP      r5,#8                 ;67
000010  d270              BCS      |L8.244|
000012  e8dff005          TBB      [pc,r5]               ;67
000016  282d              DCB      0x28,0x2d
000018  32373c41          DCB      0x32,0x37,0x3c,0x41
00001c  464b              DCB      0x46,0x4b
                  |L8.30|
00001e  f1b51f02          CMP      r5,#0x20002           ;67
000022  d057              BEQ      |L8.212|
000024  dc0e              BGT      |L8.68|
000026  f1b51f01          CMP      r5,#0x10001           ;67
00002a  d049              BEQ      |L8.192|
00002c  f5b53f00          CMP      r5,#0x20000           ;67
000030  d04b              BEQ      |L8.202|
000032  f46f3000          MVN      r0,#0x20000           ;67
000036  42c5              CMN      r5,r0                 ;67
000038  d15c              BNE      |L8.244|
;;;71     			analogin_init(aPA_0,pin);
;;;72     			break;
;;;73     		case PA_1:
;;;74     			aPA_1 = (analogin_s *)malloc(sizeof(analogin_s));
;;;75     			analogin_init(aPA_1,pin);
;;;76     			break;
;;;77     		case PA_2:
;;;78     			aPA_2 = (analogin_s *)malloc(sizeof(analogin_s));
;;;79     			analogin_init(aPA_2,pin);
;;;80     			break;
;;;81     		case PA_3:
;;;82     			aPA_3 = (analogin_s *)malloc(sizeof(analogin_s));
;;;83     			analogin_init(aPA_3,pin);
;;;84     			break;
;;;85     		case PA_4:
;;;86     			aPA_4 = (analogin_s *)malloc(sizeof(analogin_s));
;;;87     			analogin_init(aPA_4,pin);
;;;88     			break;
;;;89     		case PA_5:
;;;90     			aPA_5 = (analogin_s *)malloc(sizeof(analogin_s));
;;;91     			analogin_init(aPA_5,pin);
;;;92     			break;
;;;93     		case PA_6:
;;;94     			aPA_6 = (analogin_s *)malloc(sizeof(analogin_s));
;;;95     			analogin_init(aPA_6,pin);
;;;96     			break;
;;;97     		case PA_7:
;;;98     			aPA_7 = (analogin_s *)malloc(sizeof(analogin_s));
;;;99     			analogin_init(aPA_7,pin);
;;;100    			break;
;;;101    		case PB_0:
;;;102    			aPB_0 = (analogin_s *)malloc(sizeof(analogin_s));
;;;103    			analogin_init(aPB_0,pin);
;;;104    			break;
;;;105    		case PB_1:
;;;106    			aPB_1 = (analogin_s *)malloc(sizeof(analogin_s));
;;;107    			analogin_init(aPB_1,pin);
;;;108    			break;
;;;109    		case PC_0:
;;;110    			aPC_0 = (analogin_s *)malloc(sizeof(analogin_s));
;;;111    			analogin_init(aPC_0,pin);
;;;112    			break;
;;;113    		case PC_1:
;;;114    			aPC_1 = (analogin_s *)malloc(sizeof(analogin_s));
00003a  200c              MOVS     r0,#0xc
00003c  f7fffffe          BL       malloc
;;;115    			analogin_init(aPC_1,pin);
;;;116    			break;
000040  6320              STR      r0,[r4,#0x30]  ; aPC_1
000042  e00b              B        |L8.92|
                  |L8.68|
000044  f06f1002          MVN      r0,#0x20002           ;67
000048  1828              ADDS     r0,r5,r0              ;67
00004a  d048              BEQ      |L8.222|
00004c  2801              CMP      r0,#1                 ;67
00004e  d04b              BEQ      |L8.232|
000050  2802              CMP      r0,#2                 ;67
000052  d14f              BNE      |L8.244|
;;;117    		case PC_2:
;;;118    			aPC_2 = (analogin_s *)malloc(sizeof(analogin_s));
;;;119    			analogin_init(aPC_2,pin);
;;;120    			break;
;;;121    		case PC_3:
;;;122    			aPC_3 = (analogin_s *)malloc(sizeof(analogin_s));
;;;123    			analogin_init(aPC_3,pin);
;;;124    			break;
;;;125    		case PC_4:
;;;126    			aPC_4 = (analogin_s *)malloc(sizeof(analogin_s));
;;;127    			analogin_init(aPC_4,pin);
;;;128    			break;
;;;129    		case PC_5:
;;;130    			aPC_5 = (analogin_s *)malloc(sizeof(analogin_s));
000054  200c              MOVS     r0,#0xc
000056  f7fffffe          BL       malloc
00005a  6420              STR      r0,[r4,#0x40]  ; aPC_5
                  |L8.92|
;;;131    			analogin_init(aPC_5,pin);
00005c  4629              MOV      r1,r5
00005e  e8bd4070          POP      {r4-r6,lr}
000062  f7ffbffe          B.W      analogin_init
000066  200c              MOVS     r0,#0xc               ;70
000068  f7fffffe          BL       malloc
00006c  6060              STR      r0,[r4,#4]            ;72  ; aPA_0
00006e  e7f5              B        |L8.92|
000070  200c              MOVS     r0,#0xc               ;74
000072  f7fffffe          BL       malloc
000076  60a0              STR      r0,[r4,#8]            ;76  ; aPA_1
000078  e7f0              B        |L8.92|
00007a  200c              MOVS     r0,#0xc               ;78
00007c  f7fffffe          BL       malloc
000080  60e0              STR      r0,[r4,#0xc]          ;80  ; aPA_2
000082  e7eb              B        |L8.92|
000084  200c              MOVS     r0,#0xc               ;82
000086  f7fffffe          BL       malloc
00008a  6120              STR      r0,[r4,#0x10]         ;84  ; aPA_3
00008c  e7e6              B        |L8.92|
00008e  200c              MOVS     r0,#0xc               ;86
000090  f7fffffe          BL       malloc
000094  6160              STR      r0,[r4,#0x14]         ;88  ; aPA_4
000096  e7e1              B        |L8.92|
000098  200c              MOVS     r0,#0xc               ;90
00009a  f7fffffe          BL       malloc
00009e  61a0              STR      r0,[r4,#0x18]         ;92  ; aPA_5
0000a0  e7dc              B        |L8.92|
0000a2  200c              MOVS     r0,#0xc               ;94
0000a4  f7fffffe          BL       malloc
0000a8  61e0              STR      r0,[r4,#0x1c]         ;96  ; aPA_6
0000aa  e7d7              B        |L8.92|
0000ac  200c              MOVS     r0,#0xc               ;98
0000ae  f7fffffe          BL       malloc
0000b2  6220              STR      r0,[r4,#0x20]         ;100  ; aPA_7
0000b4  e7d2              B        |L8.92|
                  |L8.182|
0000b6  200c              MOVS     r0,#0xc               ;102
0000b8  f7fffffe          BL       malloc
0000bc  6260              STR      r0,[r4,#0x24]         ;104  ; aPB_0
0000be  e7cd              B        |L8.92|
                  |L8.192|
0000c0  200c              MOVS     r0,#0xc               ;106
0000c2  f7fffffe          BL       malloc
0000c6  62a0              STR      r0,[r4,#0x28]         ;108  ; aPB_1
0000c8  e7c8              B        |L8.92|
                  |L8.202|
0000ca  200c              MOVS     r0,#0xc               ;110
0000cc  f7fffffe          BL       malloc
0000d0  62e0              STR      r0,[r4,#0x2c]         ;112  ; aPC_0
0000d2  e7c3              B        |L8.92|
                  |L8.212|
0000d4  200c              MOVS     r0,#0xc               ;118
0000d6  f7fffffe          BL       malloc
0000da  6360              STR      r0,[r4,#0x34]         ;120  ; aPC_2
0000dc  e7be              B        |L8.92|
                  |L8.222|
0000de  200c              MOVS     r0,#0xc               ;122
0000e0  f7fffffe          BL       malloc
0000e4  63a0              STR      r0,[r4,#0x38]         ;124  ; aPC_3
0000e6  e7b9              B        |L8.92|
                  |L8.232|
0000e8  200c              MOVS     r0,#0xc               ;126
0000ea  f7fffffe          BL       malloc
0000ee  63e0              STR      r0,[r4,#0x3c]         ;128  ; aPC_4
0000f0  e7b4              B        |L8.92|
0000f2  e7ff              B        |L8.244|
                  |L8.244|
;;;132    			break;			
;;;133    		default:
;;;134    			break;
;;;135    	}      
;;;136        
;;;137    }
0000f4  bd70              POP      {r4-r6,pc}
;;;138    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L8.248|
                          DCD      ||.data||

                          AREA ||i.adc_read||, CODE, READONLY, ALIGN=2

                  adc_read PROC
;;;417    
;;;418    uint16_t adc_read(Pin pin)
000000  4602              MOV      r2,r0
;;;419    {
;;;420    	uint16_t adc_value = 0;
000002  2000              MOVS     r0,#0
;;;421    	switch (pin)
;;;422    	{
;;;423    		case PA_0:
;;;424    			adc_value = _adc_read(aPA_0);			
000004  4922              LDR      r1,|L9.144|
000006  f5b23f80          CMP      r2,#0x10000           ;421
00000a  d033              BEQ      |L9.116|
00000c  dc07              BGT      |L9.30|
00000e  2a08              CMP      r2,#8                 ;421
000010  d23c              BCS      |L9.140|
000012  e8dff002          TBB      [pc,r2]               ;421
000016  1f21              DCB      0x1f,0x21
000018  23252729          DCB      0x23,0x25,0x27,0x29
00001c  2b2d              DCB      0x2b,0x2d
                  |L9.30|
00001e  f1b21f02          CMP      r2,#0x20002           ;421
000022  d02d              BEQ      |L9.128|
000024  dc0b              BGT      |L9.62|
000026  f1b21f01          CMP      r2,#0x10001           ;421
00002a  d025              BEQ      |L9.120|
00002c  f5b23f00          CMP      r2,#0x20000           ;421
000030  d024              BEQ      |L9.124|
000032  f46f3300          MVN      r3,#0x20000           ;421
000036  42da              CMN      r2,r3                 ;421
000038  d128              BNE      |L9.140|
;;;425    			break;
;;;426    		case PA_1:
;;;427    			adc_value = _adc_read(aPA_1);			
;;;428    			break;
;;;429    		case PA_2:
;;;430    			adc_value = _adc_read(aPA_2);			
;;;431    			break;
;;;432    		case PA_3:
;;;433    			adc_value = _adc_read(aPA_3);			
;;;434    			break;
;;;435    		case PA_4:
;;;436    			adc_value = _adc_read(aPA_4);			
;;;437    			break;
;;;438    		case PA_5:
;;;439    			adc_value = _adc_read(aPA_5);			
;;;440    			break;
;;;441    		case PA_6:
;;;442    			adc_value = _adc_read(aPA_6);			
;;;443    			break;
;;;444    		case PA_7:
;;;445    			adc_value = _adc_read(aPA_7);			
;;;446    			break;
;;;447    		case PB_0:
;;;448    			adc_value = _adc_read(aPB_0);			
;;;449    			break;
;;;450    		case PB_1:
;;;451    			adc_value = _adc_read(aPB_1);			
;;;452    			break;
;;;453    		case PC_0:
;;;454    			adc_value = _adc_read(aPC_0);			
;;;455    			break;
;;;456    		case PC_1:
;;;457    			adc_value = _adc_read(aPC_1);			
;;;458    			break;
00003a  6b08              LDR      r0,[r1,#0x30]  ; aPC_1
00003c  e008              B        |L9.80|
                  |L9.62|
00003e  f06f1302          MVN      r3,#0x20002           ;421
000042  18d2              ADDS     r2,r2,r3              ;421
000044  d01e              BEQ      |L9.132|
000046  2a01              CMP      r2,#1                 ;421
000048  d01e              BEQ      |L9.136|
00004a  2a02              CMP      r2,#2                 ;421
00004c  d11e              BNE      |L9.140|
;;;459    		case PC_2:
;;;460    			adc_value = _adc_read(aPC_2);			
;;;461    			break;
;;;462    		case PC_3:
;;;463    			adc_value = _adc_read(aPC_3);			
;;;464    			break;
;;;465    		case PC_4:
;;;466    			adc_value = _adc_read(aPC_4);			
;;;467    			break;
;;;468    		case PC_5:
;;;469    			adc_value = _adc_read(aPC_5);			
00004e  6c08              LDR      r0,[r1,#0x40]  ; aPC_5
                  |L9.80|
000050  f7ffbffe          B.W      _adc_read
000054  6848              LDR      r0,[r1,#4]            ;425  ; aPA_0
000056  e7fb              B        |L9.80|
000058  6888              LDR      r0,[r1,#8]            ;428  ; aPA_1
00005a  e7f9              B        |L9.80|
00005c  68c8              LDR      r0,[r1,#0xc]          ;431  ; aPA_2
00005e  e7f7              B        |L9.80|
000060  6908              LDR      r0,[r1,#0x10]         ;434  ; aPA_3
000062  e7f5              B        |L9.80|
000064  6948              LDR      r0,[r1,#0x14]         ;437  ; aPA_4
000066  e7f3              B        |L9.80|
000068  6988              LDR      r0,[r1,#0x18]         ;440  ; aPA_5
00006a  e7f1              B        |L9.80|
00006c  69c8              LDR      r0,[r1,#0x1c]         ;443  ; aPA_6
00006e  e7ef              B        |L9.80|
000070  6a08              LDR      r0,[r1,#0x20]         ;446  ; aPA_7
000072  e7ed              B        |L9.80|
                  |L9.116|
000074  6a48              LDR      r0,[r1,#0x24]         ;449  ; aPB_0
000076  e7eb              B        |L9.80|
                  |L9.120|
000078  6a88              LDR      r0,[r1,#0x28]         ;452  ; aPB_1
00007a  e7e9              B        |L9.80|
                  |L9.124|
00007c  6ac8              LDR      r0,[r1,#0x2c]         ;455  ; aPC_0
00007e  e7e7              B        |L9.80|
                  |L9.128|
000080  6b48              LDR      r0,[r1,#0x34]         ;461  ; aPC_2
000082  e7e5              B        |L9.80|
                  |L9.132|
000084  6b88              LDR      r0,[r1,#0x38]         ;464  ; aPC_3
000086  e7e3              B        |L9.80|
                  |L9.136|
000088  6bc8              LDR      r0,[r1,#0x3c]         ;467  ; aPC_4
00008a  e7e1              B        |L9.80|
                  |L9.140|
;;;470    			break;			
;;;471    		default:
;;;472    			break;
;;;473    	}
;;;474    	return adc_value;
;;;475    }
00008c  4770              BX       lr
;;;476    
                          ENDP

00008e  0000              DCW      0x0000
                  |L9.144|
                          DCD      ||.data||

                          AREA ||i.analogin_init||, CODE, READONLY, ALIGN=2

                  analogin_init PROC
;;;164    
;;;165    void analogin_init(analogin_s *obj, Pin pin) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;166        // Get the peripheral name from the pin and assign it to the object
;;;167    		obj->adc = (ADCName)pinmap_peripheral(pin);    
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       pinmap_peripheral
;;;168        
;;;169        // Get the functions (adc channel) from the pin and assign it to the object
;;;170        uint32_t function = pinmap_function(pin);	
00000c  6020              STR      r0,[r4,#0]
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       pinmap_function
;;;171        
;;;172        obj->channel = STM_PIN_CHANNEL(function);	  
000014  f3c020c3          UBFX     r0,r0,#11,#4
000018  7220              STRB     r0,[r4,#8]
;;;173    	 
;;;174        // Configure GPIO
;;;175        pinmap_pinout(pin);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       pinmap_pinout
;;;176    
;;;177    	
;;;178        // Save pin number for the read function
;;;179        obj->pin = pin;
;;;180    	
;;;181        // The ADC initialization is done once
;;;182        if (adc_inited == 0) {
000020  4812              LDR      r0,|L10.108|
000022  6065              STR      r5,[r4,#4]
000024  6801              LDR      r1,[r0,#0]  ; adc_inited
000026  2900              CMP      r1,#0
000028  d11e              BNE      |L10.104|
;;;183            adc_inited = 1;
00002a  2201              MOVS     r2,#1
;;;184    
;;;185            // Enable ADC clock
;;;186            RCC_ADC1_CLK_ENABLE();
00002c  6002              STR      r2,[r0,#0]  ; adc_inited
00002e  4810              LDR      r0,|L10.112|
000030  6801              LDR      r1,[r0,#0]
000032  f4417180          ORR      r1,r1,#0x100
000036  6001              STR      r1,[r0,#0]
000038  6800              LDR      r0,[r0,#0]
00003a  f4007080          AND      r0,r0,#0x100
;;;187    
;;;188            // Configure ADC
;;;189            AdcHandle.Instance = (ADC_TypeDef *)(obj->adc);
00003e  9000              STR      r0,[sp,#0]
000040  480c              LDR      r0,|L10.116|
000042  6821              LDR      r1,[r4,#0]
;;;190            AdcHandle.Init.ClockPrescaler        = ((uint32_t)0x00000000);
000044  6001              STR      r1,[r0,#0]  ; AdcHandle
000046  2100              MOVS     r1,#0
;;;191            AdcHandle.Init.Resolution            = ((uint32_t)0x00000000);
000048  6041              STR      r1,[r0,#4]  ; AdcHandle
;;;192            AdcHandle.Init.ScanConvMode          = DISABLE;
00004a  6081              STR      r1,[r0,#8]  ; AdcHandle
;;;193            AdcHandle.Init.ContinuousConvMode    = DISABLE;
00004c  6101              STR      r1,[r0,#0x10]  ; AdcHandle
;;;194            AdcHandle.Init.DiscontinuousConvMode = DISABLE;
00004e  6181              STR      r1,[r0,#0x18]  ; AdcHandle
;;;195            AdcHandle.Init.NbrOfDiscConversion   = 0;
000050  6241              STR      r1,[r0,#0x24]  ; AdcHandle
;;;196            AdcHandle.Init.ExternalTrigConvEdge  = ((uint32_t)0x00000000);
000052  6281              STR      r1,[r0,#0x28]  ; AdcHandle
;;;197            AdcHandle.Init.ExternalTrigConv      = ((uint32_t)0x00000000);
000054  6301              STR      r1,[r0,#0x30]  ; AdcHandle
;;;198            AdcHandle.Init.DataAlign             = ((uint32_t)0x00000000);
000056  62c1              STR      r1,[r0,#0x2c]  ; AdcHandle
000058  60c1              STR      r1,[r0,#0xc]  ; AdcHandle
00005a  e9c01207          STRD     r1,r2,[r0,#0x1c]
;;;199            AdcHandle.Init.NbrOfConversion       = 1;
;;;200            AdcHandle.Init.DMAContinuousRequests = DISABLE;
;;;201            AdcHandle.Init.EOCSelection          = DISABLE;
;;;202            _ADC_Init(&AdcHandle); 
00005e  6141              STR      r1,[r0,#0x14]  ; AdcHandle
000060  e8bd4038          POP      {r3-r5,lr}
000064  f7ffbffe          B.W      _ADC_Init
                  |L10.104|
;;;203        }
;;;204    }
000068  bd38              POP      {r3-r5,pc}
;;;205    
                          ENDP

00006a  0000              DCW      0x0000
                  |L10.108|
                          DCD      ||.data||
                  |L10.112|
                          DCD      0x40023844
                  |L10.116|
                          DCD      ||.bss||

                          AREA ||i.local_ADC_Init||, CODE, READONLY, ALIGN=2

                  local_ADC_Init PROC
;;;229    
;;;230    static void local_ADC_Init(ADC_HandleTypeDef* hadc) {
000000  494a              LDR      r1,|L11.300|
000002  b510              PUSH     {r4,lr}
;;;231      /* Set ADC parameters */
;;;232      /* Set the ADC clock prescaler */
;;;233      ADC->CCR &= ~(ADC_CCR_ADCPRE);
000004  f8d12304          LDR      r2,[r1,#0x304]
000008  f4223240          BIC      r2,r2,#0x30000
00000c  f8c12304          STR      r2,[r1,#0x304]
;;;234      ADC->CCR |=  hadc->Init.ClockPrescaler;
000010  f8d12304          LDR      r2,[r1,#0x304]
000014  6843              LDR      r3,[r0,#4]
000016  431a              ORRS     r2,r2,r3
000018  f8c12304          STR      r2,[r1,#0x304]
;;;235      
;;;236      /* Set ADC scan mode */
;;;237      hadc->Instance->CR1 &= ~(ADC_CR1_SCAN);
00001c  6801              LDR      r1,[r0,#0]
00001e  684a              LDR      r2,[r1,#4]
000020  f4227280          BIC      r2,r2,#0x100
000024  604a              STR      r2,[r1,#4]
;;;238      hadc->Instance->CR1 |=  ADC_CR1_SCANCONV(hadc->Init.ScanConvMode);
000026  6801              LDR      r1,[r0,#0]
000028  684a              LDR      r2,[r1,#4]
00002a  6903              LDR      r3,[r0,#0x10]
00002c  ea422203          ORR      r2,r2,r3,LSL #8
000030  604a              STR      r2,[r1,#4]
;;;239      
;;;240      /* Set ADC resolution */
;;;241      hadc->Instance->CR1 &= ~(ADC_CR1_RES);
000032  6801              LDR      r1,[r0,#0]
000034  684a              LDR      r2,[r1,#4]
000036  f0227240          BIC      r2,r2,#0x3000000
00003a  604a              STR      r2,[r1,#4]
;;;242      hadc->Instance->CR1 |=  hadc->Init.Resolution;
00003c  6801              LDR      r1,[r0,#0]
00003e  684a              LDR      r2,[r1,#4]
000040  6883              LDR      r3,[r0,#8]
000042  431a              ORRS     r2,r2,r3
000044  604a              STR      r2,[r1,#4]
;;;243      
;;;244      /* Set ADC data alignment */
;;;245      hadc->Instance->CR2 &= ~(ADC_CR2_ALIGN);
000046  6801              LDR      r1,[r0,#0]
000048  688a              LDR      r2,[r1,#8]
00004a  f4226200          BIC      r2,r2,#0x800
00004e  608a              STR      r2,[r1,#8]
;;;246      hadc->Instance->CR2 |= hadc->Init.DataAlign;
000050  6801              LDR      r1,[r0,#0]
000052  688a              LDR      r2,[r1,#8]
000054  68c3              LDR      r3,[r0,#0xc]
000056  431a              ORRS     r2,r2,r3
000058  608a              STR      r2,[r1,#8]
;;;247      
;;;248      /* Enable external trigger if trigger selection is different of software  */
;;;249      /* start.                                                                 */
;;;250      /* Note: This configuration keeps the hardware feature of parameter       */
;;;251      /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
;;;252      /*       software start.                                                  */
;;;253      if(hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
00005a  6ac1              LDR      r1,[r0,#0x2c]
00005c  f06f6270          MVN      r2,#0xf000000
000060  42d1              CMN      r1,r2
;;;254      {
;;;255        /* Select external trigger to start conversion */
;;;256        hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
;;;257        hadc->Instance->CR2 |= hadc->Init.ExternalTrigConv;
;;;258        
;;;259        /* Select external trigger polarity */
;;;260        hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
;;;261        hadc->Instance->CR2 |= hadc->Init.ExternalTrigConvEdge;
;;;262      }
;;;263      else
;;;264      {
;;;265        /* Reset the external trigger */
;;;266        hadc->Instance->CR2 &= ~(ADC_CR2_EXTSEL);
000062  6801              LDR      r1,[r0,#0]
000064  688a              LDR      r2,[r1,#8]
000066  f0226270          BIC      r2,r2,#0xf000000
00006a  608a              STR      r2,[r1,#8]
;;;267        hadc->Instance->CR2 &= ~(ADC_CR2_EXTEN);
00006c  6801              LDR      r1,[r0,#0]
00006e  688a              LDR      r2,[r1,#8]
000070  d00c              BEQ      |L11.140|
000072  6ac3              LDR      r3,[r0,#0x2c]         ;257
000074  431a              ORRS     r2,r2,r3              ;257
000076  608a              STR      r2,[r1,#8]            ;257
000078  6801              LDR      r1,[r0,#0]            ;260
00007a  688a              LDR      r2,[r1,#8]            ;260
00007c  f0225240          BIC      r2,r2,#0x30000000     ;260
000080  608a              STR      r2,[r1,#8]            ;260
000082  6801              LDR      r1,[r0,#0]            ;261
000084  688a              LDR      r2,[r1,#8]            ;261
000086  6b03              LDR      r3,[r0,#0x30]         ;261
000088  431a              ORRS     r2,r2,r3              ;261
00008a  e001              B        |L11.144|
                  |L11.140|
00008c  f0225240          BIC      r2,r2,#0x30000000
                  |L11.144|
000090  608a              STR      r2,[r1,#8]
;;;268      }
;;;269      
;;;270      /* Enable or disable ADC continuous conversion mode */
;;;271      hadc->Instance->CR2 &= ~(ADC_CR2_CONT);
000092  6801              LDR      r1,[r0,#0]
000094  688a              LDR      r2,[r1,#8]
000096  f0220202          BIC      r2,r2,#2
00009a  608a              STR      r2,[r1,#8]
;;;272      hadc->Instance->CR2 |= ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode);
00009c  6801              LDR      r1,[r0,#0]
00009e  688a              LDR      r2,[r1,#8]
0000a0  6983              LDR      r3,[r0,#0x18]
0000a2  ea420243          ORR      r2,r2,r3,LSL #1
0000a6  608a              STR      r2,[r1,#8]
;;;273      
;;;274      if(hadc->Init.DiscontinuousConvMode != DISABLE)
0000a8  6a41              LDR      r1,[r0,#0x24]
0000aa  2900              CMP      r1,#0
;;;275      {  
;;;276        /* Enable the selected ADC regular discontinuous mode */
;;;277        hadc->Instance->CR1 |= (uint32_t)ADC_CR1_DISCEN;
;;;278        
;;;279        /* Set the number of channels to be converted in discontinuous mode */
;;;280        hadc->Instance->CR1 &= ~(ADC_CR1_DISCNUM);
;;;281        hadc->Instance->CR1 |=  ADC_CR1_DISCONTINUOUS(hadc->Init.NbrOfDiscConversion);
;;;282      }
;;;283      else
;;;284      {
;;;285        /* Disable the selected ADC regular discontinuous mode */
;;;286        hadc->Instance->CR1 &= ~(ADC_CR1_DISCEN);
0000ac  6801              LDR      r1,[r0,#0]
0000ae  684a              LDR      r2,[r1,#4]
0000b0  d015              BEQ      |L11.222|
0000b2  f4426200          ORR      r2,r2,#0x800          ;277
0000b6  604a              STR      r2,[r1,#4]            ;277
0000b8  6801              LDR      r1,[r0,#0]            ;280
0000ba  684a              LDR      r2,[r1,#4]            ;280
0000bc  f4224260          BIC      r2,r2,#0xe000         ;280
0000c0  604a              STR      r2,[r1,#4]            ;280
0000c2  6801              LDR      r1,[r0,#0]            ;281
0000c4  684b              LDR      r3,[r1,#4]            ;281
0000c6  f44f4460          MOV      r4,#0xe000            ;281
0000ca  6a82              LDR      r2,[r0,#0x28]         ;281
0000cc  fa94f4a4          RBIT     r4,r4                 ;281
0000d0  fab4f484          CLZ      r4,r4                 ;281
0000d4  1e52              SUBS     r2,r2,#1              ;281
0000d6  40a2              LSLS     r2,r2,r4              ;281
0000d8  4313              ORRS     r3,r3,r2              ;281
0000da  604b              STR      r3,[r1,#4]            ;281
0000dc  e002              B        |L11.228|
                  |L11.222|
0000de  f4226200          BIC      r2,r2,#0x800
0000e2  604a              STR      r2,[r1,#4]
                  |L11.228|
;;;287      }
;;;288      
;;;289      /* Set ADC number of conversion */
;;;290      hadc->Instance->SQR1 &= ~(ADC_SQR1_L);
0000e4  6801              LDR      r1,[r0,#0]
0000e6  6aca              LDR      r2,[r1,#0x2c]
0000e8  f4220270          BIC      r2,r2,#0xf00000
0000ec  62ca              STR      r2,[r1,#0x2c]
;;;291      hadc->Instance->SQR1 |=  ADC_SQR1(hadc->Init.NbrOfConversion);
0000ee  6801              LDR      r1,[r0,#0]
0000f0  6aca              LDR      r2,[r1,#0x2c]
0000f2  8c03              LDRH     r3,[r0,#0x20]
0000f4  4c0e              LDR      r4,|L11.304|
0000f6  eb045303          ADD      r3,r4,r3,LSL #20
0000fa  431a              ORRS     r2,r2,r3
0000fc  62ca              STR      r2,[r1,#0x2c]
;;;292      
;;;293      /* Enable or disable ADC DMA continuous request */
;;;294      hadc->Instance->CR2 &= ~(ADC_CR2_DDS);
0000fe  6801              LDR      r1,[r0,#0]
000100  688a              LDR      r2,[r1,#8]
000102  f4227200          BIC      r2,r2,#0x200
000106  608a              STR      r2,[r1,#8]
;;;295      hadc->Instance->CR2 |= ADC_CR2_DMAContReq(hadc->Init.DMAContinuousRequests);
000108  6801              LDR      r1,[r0,#0]
00010a  688a              LDR      r2,[r1,#8]
00010c  69c3              LDR      r3,[r0,#0x1c]
00010e  ea422243          ORR      r2,r2,r3,LSL #9
000112  608a              STR      r2,[r1,#8]
;;;296      
;;;297      /* Enable or disable ADC end of conversion selection */
;;;298      hadc->Instance->CR2 &= ~(ADC_CR2_EOCS);
000114  6801              LDR      r1,[r0,#0]
000116  688a              LDR      r2,[r1,#8]
000118  f4226280          BIC      r2,r2,#0x400
00011c  608a              STR      r2,[r1,#8]
;;;299      hadc->Instance->CR2 |= ADC_CR2_EOCSelection(hadc->Init.EOCSelection);
00011e  6801              LDR      r1,[r0,#0]
000120  688a              LDR      r2,[r1,#8]
000122  6940              LDR      r0,[r0,#0x14]
000124  ea422080          ORR      r0,r2,r0,LSL #10
000128  6088              STR      r0,[r1,#8]
;;;300    }
00012a  bd10              POP      {r4,pc}
;;;301    
                          ENDP

                  |L11.300|
                          DCD      0x40012000
                  |L11.304|
                          DCD      0xfff00000

                          AREA ||i.pin_function||, CODE, READONLY, ALIGN=2

                  pin_function PROC
;;;340    
;;;341    void pin_function(Pin pin, int data) {    
000000  b570              PUSH     {r4-r6,lr}
;;;342        // Get the pin informations
;;;343        uint32_t mode  = STM_PIN_MODE(data);
000002  f001030f          AND      r3,r1,#0xf
;;;344        uint32_t pupd  = STM_PIN_PUPD(data);
000006  f3c11202          UBFX     r2,r1,#4,#3
;;;345        uint32_t afnum = STM_PIN_AFNUM(data);
00000a  f3c114c3          UBFX     r4,r1,#7,#4
;;;346        
;;;347    	  uint32_t port_index = STM_PORT(pin);
00000e  f3c01603          UBFX     r6,r0,#4,#4
;;;348        uint32_t pin_index  = STM_PIN(pin);
000012  f000050f          AND      r5,r0,#0xf
;;;349    	
;;;350        // Enable GPIO clock
;;;351    	  uint32_t gpio_add = 0;
;;;352    		switch (port_index) {
;;;353            case PortA:
;;;354                gpio_add = GPIOA_BASE;
;;;355                RCC_GPIOA_CLK_ENABLE();
000016  491a              LDR      r1,|L12.128|
000018  b086              SUB      sp,sp,#0x18           ;341
00001a  2000              MOVS     r0,#0                 ;351
00001c  b126              CBZ      r6,|L12.40|
00001e  2e01              CMP      r6,#1                 ;352
000020  d00b              BEQ      |L12.58|
000022  2e02              CMP      r6,#2                 ;352
000024  d112              BNE      |L12.76|
000026  e021              B        |L12.108|
                  |L12.40|
000028  4816              LDR      r0,|L12.132|
00002a  680e              LDR      r6,[r1,#0]
00002c  f0460601          ORR      r6,r6,#1
000030  600e              STR      r6,[r1,#0]
000032  6809              LDR      r1,[r1,#0]
000034  f0010101          AND      r1,r1,#1
;;;356                break;
000038  e007              B        |L12.74|
                  |L12.58|
;;;357            case PortB:
;;;358                gpio_add = GPIOB_BASE;
00003a  4813              LDR      r0,|L12.136|
;;;359                RCC_GPIOB_CLK_ENABLE();
00003c  680e              LDR      r6,[r1,#0]
00003e  f0460602          ORR      r6,r6,#2
000042  600e              STR      r6,[r1,#0]
000044  6809              LDR      r1,[r1,#0]
000046  f0010102          AND      r1,r1,#2
                  |L12.74|
00004a  9105              STR      r1,[sp,#0x14]         ;355
                  |L12.76|
;;;360                break;
;;;361            case PortC:
;;;362                gpio_add = GPIOC_BASE;
;;;363                RCC_GPIOC_CLK_ENABLE();
;;;364                break;
;;;365    				default:     
;;;366                break;
;;;367        }
;;;368    	
;;;369    	
;;;370    	  //RCC_GPIOA_CLK_ENABLE();
;;;371        //uint32_t gpio_add = GPIOA_BASE;
;;;372        GPIO_TypeDef *gpio = (GPIO_TypeDef *)gpio_add;
;;;373    		
;;;374        // Configure GPIO
;;;375        GPIO_InitTypeDef GPIO_InitStructure;
;;;376        GPIO_InitStructure.Pin       = (uint32_t)(1 << pin_index);
00004c  2101              MOVS     r1,#1
00004e  40a9              LSLS     r1,r1,r5
;;;377        GPIO_InitStructure.Mode      = gpio_mode[mode];
000050  9100              STR      r1,[sp,#0]
000052  490e              LDR      r1,|L12.140|
000054  f8511023          LDR      r1,[r1,r3,LSL #2]
000058  e9cd1201          STRD     r1,r2,[sp,#4]
;;;378        GPIO_InitStructure.Pull      = pupd;
;;;379        GPIO_InitStructure.Speed     = GPIO_SPEED_HIGH;
00005c  2103              MOVS     r1,#3
00005e  e9cd1403          STRD     r1,r4,[sp,#0xc]
;;;380        GPIO_InitStructure.Alternate = afnum;
;;;381        _GPIO_Init(gpio, &GPIO_InitStructure);		
000062  4669              MOV      r1,sp
000064  f7fffffe          BL       _GPIO_Init
;;;382    }
000068  b006              ADD      sp,sp,#0x18
00006a  bd70              POP      {r4-r6,pc}
                  |L12.108|
00006c  4808              LDR      r0,|L12.144|
00006e  680e              LDR      r6,[r1,#0]            ;363
000070  f0460604          ORR      r6,r6,#4              ;363
000074  600e              STR      r6,[r1,#0]            ;363
000076  6809              LDR      r1,[r1,#0]            ;363
000078  f0010104          AND      r1,r1,#4              ;363
00007c  e7e5              B        |L12.74|
;;;383    
                          ENDP

00007e  0000              DCW      0x0000
                  |L12.128|
                          DCD      0x40023830
                  |L12.132|
                          DCD      0x40020000
                  |L12.136|
                          DCD      0x40020400
                  |L12.140|
                          DCD      ||.constdata||+0xcc
                  |L12.144|
                          DCD      0x40020800

                          AREA ||i.pinmap_find_function||, CODE, READONLY, ALIGN=2

                  pinmap_find_function PROC
;;;304    
;;;305    uint32_t pinmap_find_function(Pin pin) {
000000  4905              LDR      r1,|L13.24|
000002  e004              B        |L13.14|
                  |L13.4|
;;;306    	const PinMap* map = PinMap_ADC;
;;;307        while (map->pin != NC) {
;;;308            if (map->pin == pin)
000004  4282              CMP      r2,r0
000006  d101              BNE      |L13.12|
;;;309                return map->function;
000008  6888              LDR      r0,[r1,#8]
;;;310            map++;
;;;311        }
;;;312        return (uint32_t)NC;
;;;313    }
00000a  4770              BX       lr
                  |L13.12|
00000c  310c              ADDS     r1,r1,#0xc
                  |L13.14|
00000e  680a              LDR      r2,[r1,#0]            ;307
000010  1c53              ADDS     r3,r2,#1              ;307
000012  d1f7              BNE      |L13.4|
000014  1e58              SUBS     r0,r3,#1              ;312
000016  4770              BX       lr
;;;314    
                          ENDP

                  |L13.24|
                          DCD      ||.constdata||

                          AREA ||i.pinmap_find_peripheral||, CODE, READONLY, ALIGN=2

                  pinmap_find_peripheral PROC
;;;140    
;;;141    uint32_t pinmap_find_peripheral(Pin pin) {
000000  4905              LDR      r1,|L14.24|
000002  e004              B        |L14.14|
                  |L14.4|
;;;142    	const PinMap* map = PinMap_ADC;
;;;143        while (map->pin != NC) {
;;;144            if (map->pin == pin)
000004  4282              CMP      r2,r0
000006  d101              BNE      |L14.12|
;;;145                return map->peripheral;
000008  6848              LDR      r0,[r1,#4]
;;;146            map++;
;;;147        }
;;;148        return (uint32_t)NC;
;;;149    }
00000a  4770              BX       lr
                  |L14.12|
00000c  310c              ADDS     r1,r1,#0xc
                  |L14.14|
00000e  680a              LDR      r2,[r1,#0]            ;143
000010  1c53              ADDS     r3,r2,#1              ;143
000012  d1f7              BNE      |L14.4|
000014  1e58              SUBS     r0,r3,#1              ;148
000016  4770              BX       lr
;;;150    
                          ENDP

                  |L14.24|
                          DCD      ||.constdata||

                          AREA ||i.pinmap_function||, CODE, READONLY, ALIGN=1

                  pinmap_function PROC
;;;317    
;;;318    uint32_t pinmap_function(Pin pin) {    
000000  f7ffbffe          B.W      pinmap_find_function
;;;319        return pinmap_find_function(pin);	
;;;320    }
;;;321    
                          ENDP


                          AREA ||i.pinmap_peripheral||, CODE, READONLY, ALIGN=1

                  pinmap_peripheral PROC
;;;152    
;;;153    uint32_t pinmap_peripheral(Pin pin) {
000000  f04f31ff          MOV      r1,#0xffffffff
;;;154       
;;;155    	uint32_t peripheral = (uint32_t)NC;
;;;156    
;;;157        if (pin == (Pin)NC)
000004  1c42              ADDS     r2,r0,#1
000006  d001              BEQ      |L16.12|
;;;158            return (uint32_t)NC;
;;;159        peripheral = pinmap_find_peripheral(pin);    
000008  f7ffbffe          B.W      pinmap_find_peripheral
                  |L16.12|
00000c  4608              MOV      r0,r1                 ;158
;;;160        return peripheral;
;;;161    }
00000e  4770              BX       lr
;;;162    
                          ENDP


                          AREA ||i.pinmap_pinout||, CODE, READONLY, ALIGN=2

                  pinmap_pinout PROC
;;;324    
;;;325    void pinmap_pinout(Pin pin) {
000000  4906              LDR      r1,|L17.28|
;;;326    	const PinMap* map = PinMap_ADC;
;;;327      if (pin == NC)
000002  1c42              ADDS     r2,r0,#1
000004  d009              BEQ      |L17.26|
000006  e005              B        |L17.20|
                  |L17.8|
;;;328            return;
;;;329    
;;;330      while (map->pin != NC) {
;;;331            if (map->pin == pin) {
000008  4282              CMP      r2,r0
00000a  d102              BNE      |L17.18|
;;;332                pin_function(pin, map->function);
00000c  6889              LDR      r1,[r1,#8]
00000e  f7ffbffe          B.W      pin_function
                  |L17.18|
000012  310c              ADDS     r1,r1,#0xc
                  |L17.20|
000014  680a              LDR      r2,[r1,#0]            ;330
000016  1c53              ADDS     r3,r2,#1              ;330
000018  d1f6              BNE      |L17.8|
                  |L17.26|
;;;333                return;
;;;334            }
;;;335          map++;
;;;336      }    
;;;337    }
00001a  4770              BX       lr
;;;338    
                          ENDP

                  |L17.28|
                          DCD      ||.constdata||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  AdcHandle
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  PinMap_ADC
                          DCD      0x00000000
                          DCD      0x40012000
                          DCD      0x00000005
                          DCD      0x00000001
                          DCD      0x40012000
                          DCD      0x00000805
                          DCD      0x00000002
                          DCD      0x40012000
                          DCD      0x00001005
                          DCD      0x00000003
                          DCD      0x40012000
                          DCD      0x00001805
                          DCD      0x00000004
                          DCD      0x40012000
                          DCD      0x00002005
                          DCD      0x00000005
                          DCD      0x40012000
                          DCD      0x00002805
                          DCD      0x00000006
                          DCD      0x40012000
                          DCD      0x00003005
                          DCD      0x00000007
                          DCD      0x40012000
                          DCD      0x00003805
                          DCD      0x00010000
                          DCD      0x40012000
                          DCD      0x00004005
                          DCD      0x00010001
                          DCD      0x40012000
                          DCD      0x00004805
                          DCD      0x00020000
                          DCD      0x40012000
                          DCD      0x00005005
                          DCD      0x00020001
                          DCD      0x40012000
                          DCD      0x00005805
                          DCD      0x00020002
                          DCD      0x40012000
                          DCD      0x00006005
                          DCD      0x00020003
                          DCD      0x40012000
                          DCD      0x00006805
                          DCD      0x00020004
                          DCD      0x40012000
                          DCD      0x00007005
                          DCD      0x00020005
                          DCD      0x40012000
                          DCD      0x00007805
                          DCD      0xffffffff
                          DCD      0x00000000
                          DCD      0x00000000
                  gpio_mode
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000011
                          DCD      0x00000002
                          DCD      0x00000012
                          DCD      0x00000003
                          DCD      0x10110000
                          DCD      0x10210000
                          DCD      0x10310000
                          DCD      0x10120000
                          DCD      0x10220000
                          DCD      0x10320000
                          DCD      0x10000000

                          AREA ||.data||, DATA, ALIGN=2

                  adc_inited
                          DCD      0x00000000
                  aPA_0
                          DCD      0x00000000
                  aPA_1
                          DCD      0x00000000
                  aPA_2
                          DCD      0x00000000
                  aPA_3
                          DCD      0x00000000
                  aPA_4
                          DCD      0x00000000
                  aPA_5
                          DCD      0x00000000
                  aPA_6
                          DCD      0x00000000
                  aPA_7
                          DCD      0x00000000
                  aPB_0
                          DCD      0x00000000
                  aPB_1
                          DCD      0x00000000
                  aPC_0
                          DCD      0x00000000
                  aPC_1
                          DCD      0x00000000
                  aPC_2
                          DCD      0x00000000
                  aPC_3
                          DCD      0x00000000
                  aPC_4
                          DCD      0x00000000
                  aPC_5
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "drivers\\adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_e96f21e9____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___5_adc_c_e96f21e9____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_e96f21e9____REVSH|
#line 223
|__asm___5_adc_c_e96f21e9____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_adc_c_e96f21e9____RRX|
#line 410
|__asm___5_adc_c_e96f21e9____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
