; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timer.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O3 --diag_suppress=9931 -I.\drivers -I.\RTE\_Target_1 -Ic:\Keil_v5\ARM\PACK\ARM\CMSIS\5.8.0\CMSIS\Core\Include -Ic:\Keil_v5\ARM\PACK\Keil\STM32F4xx_DFP\2.15.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=534 -D_RTE_ -DSTM32F401xE -D_RTE_ --omf_browse=.\objects\timer.crf drivers\timer.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;44     
;;;45     void SysTick_Handler(void)
000000  4801              LDR      r0,|L1.8|
;;;46     {
;;;47     	timer_callback();
000002  6800              LDR      r0,[r0,#0]  ; timer_callback
000004  4700              BX       r0
;;;48     }
;;;49     
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.__NVIC_SetPriority||, CODE, READONLY, ALIGN=1

                  __NVIC_SetPriority PROC
;;;1813    */
;;;1814   __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
000000  0709              LSLS     r1,r1,#28
;;;1815   {
;;;1816     if ((int32_t)(IRQn) >= 0)
;;;1817     {
;;;1818       NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
000002  0e09              LSRS     r1,r1,#24
000004  2800              CMP      r0,#0                 ;1816
000006  db04              BLT      |L2.18|
000008  f10020e0          ADD      r0,r0,#0xe000e000     ;1815
00000c  f8801400          STRB     r1,[r0,#0x400]
;;;1819     }
;;;1820     else
;;;1821     {
;;;1822       SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
;;;1823     }
;;;1824   }
000010  4770              BX       lr
                  |L2.18|
000012  f000000f          AND      r0,r0,#0xf            ;1822
000016  f10020e0          ADD      r0,r0,#0xe000e000     ;1822
00001a  f8801d14          STRB     r1,[r0,#0xd14]        ;1822
00001e  4770              BX       lr
;;;1825   
                          ENDP


                          AREA ||i.timer_disable||, CODE, READONLY, ALIGN=1

                  timer_disable PROC
;;;27     
;;;28     void timer_disable(void) {
000000  f04f20e0          MOV      r0,#0xe000e000
;;;29     	SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk;
000004  6901              LDR      r1,[r0,#0x10]
000006  f0210101          BIC      r1,r1,#1
00000a  6101              STR      r1,[r0,#0x10]
;;;30     }
00000c  4770              BX       lr
;;;31     
                          ENDP


                          AREA ||i.timer_enable||, CODE, READONLY, ALIGN=1

                  timer_enable PROC
;;;21     
;;;22     void timer_enable(void) {
000000  f04f21e0          MOV      r1,#0xe000e000
;;;23     	 SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
000004  2007              MOVS     r0,#7
000006  6108              STR      r0,[r1,#0x10]
;;;24                        SysTick_CTRL_TICKINT_Msk   |
;;;25                        SysTick_CTRL_ENABLE_Msk;
;;;26     }
000008  4770              BX       lr
;;;27     
                          ENDP


                          AREA ||i.timer_init||, CODE, READONLY, ALIGN=2

                  timer_init PROC
;;;7      
;;;8      void timer_init(uint32_t timestamp) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;9      
;;;10     	// The timer should be able to tick anywhere from every
;;;11     	// microsecond to every second. In the unlikely event that
;;;12     	// the hardware is unable to divide down to a second, a
;;;13     	// software divider should be implemented.
;;;14     
;;;15     		uint32_t tick_us = (SystemCoreClock)/1e6;
000004  4816              LDR      r0,|L5.96|
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  f7fffffe          BL       __aeabi_ui2d
00000c  ed9f1b15          VLDR     d1,|L5.100|
000010  ec532b11          VMOV     r2,r3,d1
000014  f7fffffe          BL       __aeabi_ddiv
000018  f7fffffe          BL       __aeabi_d2uiz
;;;16     		tick_us = tick_us*timestamp;
00001c  4360              MULS     r0,r4,r0
00001e  2400              MOVS     r4,#0
000020  1e65              SUBS     r5,r4,#1
000022  1e40              SUBS     r0,r0,#1
000024  f1b07f80          CMP      r0,#0x1000000
000028  d209              BCS      |L5.62|
00002a  f04f26e0          MOV      r6,#0xe000e000
00002e  6170              STR      r0,[r6,#0x14]
000030  210f              MOVS     r1,#0xf
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       __NVIC_SetPriority
000038  61b4              STR      r4,[r6,#0x18]
00003a  2007              MOVS     r0,#7
00003c  6130              STR      r0,[r6,#0x10]
                  |L5.62|
00003e  480b              LDR      r0,|L5.108|
000040  6800              LDR      r0,[r0,#0]
000042  f3c02002          UBFX     r0,r0,#8,#3
000046  1d01              ADDS     r1,r0,#4
000048  2907              CMP      r1,#7
00004a  d201              BCS      |L5.80|
00004c  2000              MOVS     r0,#0
00004e  e000              B        |L5.82|
                  |L5.80|
000050  1ec0              SUBS     r0,r0,#3
                  |L5.82|
000052  fa04f100          LSL      r1,r4,r0
;;;17     		SysTick_Config(tick_us);
;;;18     		NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 0, 0));
000056  4628              MOV      r0,r5
000058  e8bd4070          POP      {r4-r6,lr}
00005c  f7ffbffe          B.W      __NVIC_SetPriority
;;;19     
;;;20     	}
;;;21     
                          ENDP

                  |L5.96|
                          DCD      SystemCoreClock
                  |L5.100|
000064  00000000          DCFD     0x412e848000000000 ; 1000000
000068  412e8480
                  |L5.108|
                          DCD      0xe000ed0c

                          AREA ||i.timer_set_callback||, CODE, READONLY, ALIGN=2

                  timer_set_callback PROC
;;;31     
;;;32     void timer_set_callback(void (*callback)(void)) {
000000  4901              LDR      r1,|L6.8|
;;;33     	// Set up and enable the interrupt.
;;;34     
;;;35     	// The callback function should be stored in an internal
;;;36     	// static function pointer.
;;;37     
;;;38     	// The callback function should be executed periodically,
;;;39     	// according to the period specified by the previous call
;;;40     	// of timer_init.
;;;41     	timer_callback = callback;
000002  6008              STR      r0,[r1,#0]  ; timer_callback
;;;42     
;;;43     }
000004  4770              BX       lr
;;;44     
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  timer_callback
                          DCD      0x00000000

                          AREA ||area_number.10||, DATA, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.data||
                  timer_period
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "drivers\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_651163fb____REV16|
#line 208 "c:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.8.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_651163fb____REV16| PROC
#line 209

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_651163fb____REVSH|
#line 223
|__asm___7_timer_c_651163fb____REVSH| PROC
#line 224

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_651163fb____RRX|
#line 410
|__asm___7_timer_c_651163fb____RRX| PROC
#line 411

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
